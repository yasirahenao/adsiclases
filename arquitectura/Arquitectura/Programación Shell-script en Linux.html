<!DOCTYPE html>
<!-- saved from url=(0048)http://trajano.us.es/~fjfj/shell/shellscript.htm -->
<html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="Description" content="Autor: F.J. Fernández-Jiménez,
    Contenido: Manual práctico de programación shell-script en Linux centrado en la sintaxis de shell propuesta por el estándar POSIX IEEE 1003.2.">
    
		<title>Programación Shell-script en Linux</title>
    <style>
		body {
			font-family: Verdana; 
		}
        
		.portada {
			margin: 1em auto auto auto;
			width: 95%;
			text-align: center;
		}
		
		.toc1, .toc2, .toc3, .toc4 {
			text-align: left;
			
		}
		.toc1 {
			text-indent: -1em;
			margin-left: 1em;
		}
		.toc2 {
			text-indent: -2em;
			margin-left: 3em;
		}
		.toc3 {
			text-indent: -3em;
			margin-left: 6em;
		}
		.toc4 {
			text-indent: -3em;
			margin-left: 9em;
		}
		
		.toc1 a {
			font-size: 1.2em;
			font-weight: bold;
			text-decoration: none;
			font-variant-caps: small-caps;
		}
		.toc2 a {
			font-weight: bold;
			text-decoration: none;
		}
		.toc3 a {
			text-decoration: none;
		}
		.toc4 a {
			font-size: 1em;
			font-style: oblique;
			text-decoration: none;
		}
  	.tareaTitulo {
			background:#D9D9D9;
			width: 1em;
		}
		.tareaTitulo p {
			transform: rotate(-90deg);
		}
		.tareaContenido {
				padding:0cm 5.4pt 0cm 5.4pt;
				overflow: scroll;
		}
		
		li, ol {
			margin-bottom: 10px;
			margin-top: 10px;	
		}
		
		.nombreFichero {
			text-align: right;
			margin-bottom: 0;	
		}
		
		.contenidoFichero {
			width: 90%;
			margin: 0 5% 0 5%;
			background: #E5E5E5;
			padding: 5px;
			font-family: monospace;
		}
		
		.tablaNormal {
				width: 90%;
				margin: auto;
				border-collapse: collapse;
				vertical-align: top;
				page-break-inside: avoid;
		}
		
		.tablaTarea {
				margin-left:5.4pt;
				border-collapse:collapse;
				border:none;
				table-layout: fixed;
				width: 100vw;
		}
		.alerta {
				border:solid black 1.0pt;
				background:#E5E5E5;
				padding:0cm 5.0pt 0cm 5.0pt;
		}
						
		.celdaDestacada {
				background:#CCCCCC;
				
		}
		
		.tablaDefiniciones td {
				width: 50%;
				border: solid black 1.0pt;
				padding: 10px;
		}

		.tablaDefiniciones3 td {
				
				border: solid black 1.0pt;
				padding: 2px;
		}       

		a:link    {color: #660000;}
		a:visited {color: #660000;}
		a:hover   {color: red;}
		h1,h2,h3,h4 {color: #660000; font-weight: bold}
		hr {
		  background-color: #9B192E;
		  height: 1px;
		  border-style: none;
		  margin-top: 0px;
		  padding-top: 0px;
		}
		h1 {
		
			clear: both;
			font-size: 2.2em;
			font-weight: bold;
			margin: 1em 0px 1em;
		}
		h2 {
			clear: both;
			font-size: 1.8em;
			font-weight: bold;
			margin: 1.275em 0px 0.85em;
			border-bottom-width: 1px;
			border-bottom-style: solid;
			border-bottom-color: rgb(230, 230, 230);
			line-height: 1.7em;
		}
		.shellscript {
			font-family: Consolas, Inconsolata, Courier, monospace;
			white-space: pre;
			word-break: break-all;
			word-wrap: break-word;
			color: rgb(100, 0, 50);			
		}
		pre {
			border-top-left-radius: 3px;
			border-top-right-radius: 3px;
			border-bottom-right-radius: 3px;
			border-bottom-left-radius: 3px;
			border-collapse: collapse;
			word-break: break-all;
			word-wrap: break-word;
			overflow: auto;
			margin: 0px 2px;
			letter-spacing: -1px;
			padding: 0.5em;
			font-size: 1em;
			font-family: Consolas, Inconsolata, Courier, monospace;
			white-space: pre;
			word-break: break-all;
			word-wrap: break-word;
			
		}
		pre.shellscript {
			display: block;
			border-top-left-radius: 3px;
			border-top-right-radius: 3px;
			border-bottom-right-radius: 3px;
			border-bottom-left-radius: 3px;
			border: 1px solid rgb(204, 204, 204);
			margin: 0px 2px;
			font-size: 1em;
			letter-spacing: -1px;
			/*font-weight: bold;*/
			padding: 0.5em;
			background-color: rgb(240, 240, 240);
			background-position: initial;
			background-repeat: initial;
			color: black;
			border-collapse: collapse;
		}

		p .shellscript, li .shellscript {
			border-top-left-radius: 3px;
			border-top-right-radius: 3px;
			border-bottom-right-radius: 3px;
			border-bottom-left-radius: 3px;
			border: 1px solid rgb(204, 204, 204);
			padding: 0px 5px;
			margin: 0px 2px;
			border-collapse: collapse;
		}
		
		.centrado {
			text-align: center;
		}
	</style>
  </head>
  <body lang="es">
    <div class="portada">
			<hr>
      <h1>Programación Shell-script en Linux</h1>
			<hr>
      <p>
        <b>
          <span><a href="http://trajano.us.es/">Departamento de Ingeniería Telemática (DIT)</a></span>
        </b>
      </p>
      <p>
        <b>
          <span><a href="http://www.us.es/">Universidad de Sevilla</a></span>
        </b>
      </p>
      <br>
      <p>
        <span><a href="http://trajano.us.es/~fjfj">Francisco José Fernández Jiménez</a></span>
      </p>
      <p>
        <span><a href="http://trajano.us.es/~fjmc">Fco. Javier Muñoz Calle</a></span>
      </p>
      <p>
        <span>©2018</span>
        <br>
      </p>
      <h2>ÍNDICE</h2>
      <p class="toc1">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081191" id="_Idx444081191">1 Objetivos y alcance</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081192" id="_Idx444081192">1.1 
         Introducción</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081193" id="_Idx444081193">1.2 
         Objetivo</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081195" id="_Idx444081195">1.3 
         Documentación de apoyo</a>
      </p>
      <p class="toc1">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081196" id="_Idx444081196">2 Estructura básica de shell-scripts. Invocación</a>
      </p>
      <p class="toc1">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081197" id="_Idx444081197">3 Sintaxis de Shell-scripts</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081198" id="_Idx444081198">3.1 
         Funcionamiento general del shell</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081199" id="_Idx444081199">3.2 
         Entrecomillado y carácter de escape</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081200" id="_Idx444081200">3.3 
         Parámetros y variables</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081201" id="_Idx444081201">3.3.1 
         Variables</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081202" id="_Idx444081202">3.3.1.1 Variables del shell</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081203" id="_Idx444081203">3.3.2 
         Parámetros posicionales</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081204" id="_Idx444081204">3.3.3 
         Parámetros especiales</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081205" id="_Idx444081205">3.3.4 
         Exportación de variables</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081206" id="_Idx444081206">3.4 
         Expansiones y sustituciones</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081207" id="_Idx444081207">3.4.1 
         Expansión de ~</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081208" id="_Idx444081208">3.4.2 
         Expansión de parámetros y variables</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081209" id="_Idx444081209">3.4.3 
         Sustitución de comando</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081210" id="_Idx444081210">3.4.4 
         Expansión aritmética</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081211" id="_Idx444081211">3.4.5 
         Expansión de ruta</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081212" id="_Idx444081212">3.5 
         Comandos del shell</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081213" id="_Idx444081213">3.5.1 
         Comandos simples</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081214" id="_Idx444081214">3.5.2 
         Tuberías</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081215" id="_Idx444081215">3.5.3 
         Listas AND-OR</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081216" id="_Idx444081216">3.5.4 
         Listas</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081217" id="_Idx444081217">3.5.4.1 Listas secuenciales</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081218" id="_Idx444081218">3.5.4.2 Listas asíncronas</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081219" id="_Idx444081219">3.5.4.3 Listas mixtas</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081220" id="_Idx444081220">3.5.5 
         Listas compuestas</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081221" id="_Idx444081221">3.5.6 
         Comandos compuestos o estructuras de control</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081222" id="_Idx444081222">3.5.6.1 Secuencial. Agrupación de comandos.</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081223" id="_Idx444081223">3.5.6.2 Condicional: if-elif-else</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081224" id="_Idx444081224">
        <span>3.5.6.3</span> Condicional 
        <span>: case</span></a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081225" id="_Idx444081225">3.5.6.4 Bucles incondicionales: for</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081226" id="_Idx444081226">3.5.6.5 Bucles condicionales: while y until</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081227" id="_Idx444081227">3.5.6.6 Ruptura de sentencias de control</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081228" id="_Idx444081228">3.5.7 
         Funciones </a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081229" id="_Idx444081229">3.6 
         Uso de comandos y aplicaciones</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081230" id="_Idx444081230">3.6.1 
         Comandos internos</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081231" id="_Idx444081231">3.6.1.1 Salida del proceso shell actual, exit</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081232" id="_Idx444081232">3.6.1.2 Entrada estándar a un shell-script, read</a>
      </p>
      <p class="toc4">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081233" id="_Idx444081233">3.6.1.3 Construcción de comandos en tiempo de ejecución: eval</a>
      </p>
      <p class="toc3">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081234" id="_Idx444081234">3.6.2 
         Comandos externos</a>
      </p>
      <p class="toc1">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081235" id="_Idx444081235">4 Depuración de shell-scripts</a>
      </p>
      <p class="toc1">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081236" id="_Idx444081236">5 Propuesta de ejercicios</a>
      </p>
      <p class="toc1">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081237" id="_Idx444081237">
        <span>6</span> 
        <span>Anexo: Descriptores de ficheros y redirecciones</span></a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081238" id="_Idx444081238">6.1 
         Asociación para el Proceso Shell actual</a>
      </p>
      <p class="toc2">
        <a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Toc444081239" id="_Idx444081239">6.2 
         Asociación para un comando (proceso hijo) invocado desde el shell</a>
      </p>
      <p>&nbsp;</p>
    </div>
    <div class="WordSection2">
      <h1 id="_Toc444081191"><a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081191">1 Objetivos y alcance</a>
      </h1>
      <h2 id="_Toc444081192"><a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081192">1.1 Introducción</a>
      </h2>
      <p>El intérprete de comandos o shell es un programa que permite a los usuarios interactuar con el sistema,
      procesando las órdenes que se le indican. Los comandos invocables desde el shell pueden clasificarse en internos
      (corresponden en realidad a órdenes interpretadas por el propio shell) y externos (corresponden a ficheros ejecutables
      externos al shell). Además de comandos, los shells ofrecen otros elementos para mejorar su funcionalidad, tales como
      variables, funciones o estructuras de control. El conjunto de comandos internos y elementos disponibles, así como su
      sintaxis, dependerá del shell concreto empleado.</p>
      <p>Además de utilizar el shell desde la línea de comandos (basada en el prompt como la indicación del shell
      para anunciar que espera una orden del usuario), puede emplearse para la interpretación de shell-scripts. Un shell-script o
      "guión de órdenes" es un fichero de texto que contiene un conjunto de comandos y órdenes interpretables por el
      shell.</p>
      <p>En los S.O.’s Unix existen múltiples implementaciones de shell (en Windows, el equivalente serían los programas "command.com" o "cmd.exe"). Atendiendo al shell del que proceden y a su similitud sintáctica (incluyendo sus comandos internos), los shells de
      Unix pueden clasificarse en dos grandes familias (existen algunos shell adicionales, de uso residual y dentro de los shells de una misma familia también existen diferencias, pero gran parte de su sintaxis es común):</p>
      <ol>
        <li> 
        <span class="shellscript">sh</span> (Bourne Shell): este shell fue usado desde las primeras versiones de Unix (Unix Versión 7). Recibe ese nombre por su desarrollador, Stephen Bourne, de los Laboratorios Bell de AT&amp;T. 
        <span>A raíz de él han surgido múltiples shells, tales como <span class="shellscript">zsh</span> (Z shell), <span class="shellscript">ash</span> (almquist shell),
        <span class="shellscript">bash</span> (Bourne again shell), <span class="shellscript">dash</span> (Debian almquist shell) o <span class="shellscript">ksh</span> (Korn shell).</span> 
        <span>Por su mayor uso pueden destacarse:</span>
        <ul>
          <li>
            <span><span class="shellscript">bash</span>: fue desarrollado para ser un superconjunto de la funcionalidad del Bourne Shell (en la que
            incluye funcionalidades de ksh y csh), siendo el intérprete de comandos asignado por defecto a los usuarios en las
            distribuciones de Linux, por lo que es el shell empleado en la mayoría de las consolas de comandos de Linux. Se
            caracteriza por una gran funcionalidad adicional a la del Bourne Shell. Como ficheros personales de los usuarios emplea
            <span class="shellscript">$HOME/.bashrc</span> y <span class="shellscript">.bash_profile</span>.</span>
          </li>
          <li>
            <span><span class="shellscript">dash</span> (Debian almquist shell), derivado directo de ash, se caracteriza por ser mucho más ligero
            (depende de menos bibliotecas) y rápido que otros shells, tales como bash, aunque con menos características
            funcionales. El fichero personal del usuario es <span class="shellscript">$HOME/.profile</span>.</span>
          </li>
          <li>
          <span><span class="shellscript">ksh</span> (Korn shell): destaca por</span> sus funciones avanzadas para manejar archivos, pudiendo competir
          con lenguajes de programación especializados tales como awk o perl.</li>
        </ul>
        <p>Bourne Shell ha llegado a convertirse en un estándar de facto de tal modo que todos los sistemas Unix tienen, al menos,
        una implementación del Bourne Shell (o un shell compatible con él), ubicada en <span class="shellscript">/bin/sh</span>. En el caso concreto de
        los S.O.’s UNIX Linux, no existe ninguna implementación del Bourne Shell, manteniéndose la entrada&nbsp;
        <span class="shellscript">/bin/sh</span> (así como su manual <span class="shellscript">man sh</span>) como un enlace simbólico a una implementación de shell
        compatible. 
        <span>En concreto:</span></p>
        <ul>
          <li>En algunos S.O’s Linux se enlaza a <span class="shellscript">/bin/bash</span>.</li>
          <li>En Debian, desde Debian Lenny "5.0" (en Ubuntu desde la versión 6.10) se enlaza a <span class="shellscript">/bin/dash</span>: de
          este modo, estas distribuciones pretenden hacer uso de:
          <ul>
            <li><span class="shellscript">dash</span>: para los shell scripts empleados en el arranque del sistema (cuyo shebang tradicionalmente
            siempre ha sido <span class="shellscript">#!/bin/sh</span>), aprovechando la mayor rapidez de este intérprete.</li>
            <li>
              <span><span class="shellscript">bash</span>: en las consolas de comandos y scripts de servicios de los usuarios, de modo que éstos puedan
              aprovechar la mayor funcionalidad que éste intérprete ofrece.</span>
            </li>
          </ul></li>
        </ul></li>
        <li><span class="shellscript">csh</span> (C shell): caracterizado por presentar una sintaxis muy parecida a la del lenguaje de programación C.
        Como shell derivados destaca <span class="shellscript">tcsh</span>. Estos shell cuentan con un nivel de uso muy inferior respecto a los de la
        familia Bourne Shell.
        <p>Para intentar homogeneizar esta diversidad de shells, el IEEE definió un estándar de "intérprete
        de comandos" bajo la especificación POSIX 1003.2 (también recogida como ISO 9945.2). La creación de dicho estándar se
        basó en la sintaxis que presentaban múltiples shells de la familia Bourne shell (el propio Bourne Shell de Unix Versión 7,
        implementaciones en UNIX System V y BSD, así como <span class="shellscript">ksh</span>). Esto ha llevado a que la gran mayoría de los shells derivados del
        Bourne Shell, tales como <span class="shellscript">bash</span>, <span class="shellscript">dash</span> o <span class="shellscript">ksh</span>, den soporte a este estándar POSIX (mientras que los derivados del <span class="shellscript">csh</span> no). En
        concreto:</p>
        <ul>
          <li><span class="shellscript">bash</span>: respeta completamente el estándar POSIX, sobre el que añade un número considerable de extensiones (estructura
          select, arrays, mayor número de operadores,...).</li>
          <li><span class="shellscript">dash</span>: conforme al estándar POSIX IEEE 1003.2, sólo ampliado con algunas extensiones Berkeley. De forma precisa, tal como indica el manual del intérprete dash de su sistema (<span class="shellscript">man dash</span>), la línea de
	desarrollo de <span class="shellscript">dash</span> pretende que éste satisfaga el estándar POSIX de shells IEEE 1003.2, propósito casi logrado
	en la actualidad (sólo presenta algunas características faltantes, como la variable <span class="shellscript">$LINENO</span>).</li>
        </ul></li>
      </ol>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>Ejecute en su sistema Debian el comando 
              <span class="shellscript">ls -l /bin/sh</span>, y compruebe cómo efectivamente corresponde a un enlace
              simbólico al intérprete 
              <span class="shellscript">/bin/dash</span>. Asimismo, consulte el manual 
              <span class="shellscript">man sh</span>, comprobando cómo efectivamente obtiene el manual del intérprete
              
              <span class="shellscript">dash</span>.</li>
              <li>Ejecute los comandos <span class="shellscript">ls -l /bin/dash</span> y <span class="shellscript">ls -l /bin/bash</span> para comprobar cómo efectivamente dispone de dichos shells
              en su sistema. Puede obtener las versiones instaladas mediante <span class="shellscript">dpkg -s dash</span> y <span class="shellscript">bash –version</span>.</li>
              <li>La mayoría de los shell-scripts implicados en el proceso de arranque del sistema se encuentran en la carpeta
              <span class="shellscript">/etc/init.d/</span>. Por ejemplo, mire el contenido del fichero <span class="shellscript">/etc/init.d/rc</span> (encargado del arranque de los servicios) y compruebe cómo
              la primera línea de dicho script es <span class="shellscript">#!/bin/sh</span>, lo que indica que es interpretado por el shell <span class="shellscript">/bin/dash</span>.</li>
              <li>Analice el fichero <span class="shellscript">/etc/passwd</span> y compruebe cómo los usuarios <span class="shellscript">dit</span> y <span class="shellscript">root</span> tienen asignado el shell <span class="shellscript">bash</span>. Abra una consola de comandos con el usuario <span class="shellscript">dit</span> y ejecute el comando <span class="shellscript">ps ax | grep bash</span>, comprobando cómo el proceso del intérprete de comandos
              usado efectivamente corresponde al shell bash (proceso <span class="shellscript">-bash</span>). Abra una sesión con el usuario <span class="shellscript">root</span> y realice la misma prueba, comprobando cómo igualmente se está usando
              bash.</li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <h2 id="_Toc444081193"><a href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081193">1.2 Objetivo</a>
      </h2>
      <p>El objetivo es introducir el uso del lenguaje de programación de
      shell-scripts. Consecuentemente, nos centraremos en la sintaxis de shell propuesta por el estándar POSIX
      IEEE 1003.2 lo que, conforme a lo antes indicado, se traduce en que todo lo visto aquí podrá ser utilizado en dash, bash y
      cualquier otro shell que satisfaga dicho estándar. Sobre la base de este documento podrá profundizarse analizando las
      funcionalidades adicionales añadidas por cada shell, siendo de especial interés, dado su uso, las aportadas por bash.</p>
      <h2>1.3 
      <a id="_Toc444081195" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081195">Documentación de apoyo</a></h2>
      <ul>
        <li>Estándar de "intérprete de comandos" de la especificación POSIX ( 
        <a href="http://pubs.opengroup.org/onlinepubs/009695399/">IEEE Standard 1003.1 2004/ISO 9945.2)</a></li>
        <li>
          The Linux Command Line (Openbook)". E. William, Jr. Shotts. San Francisco, 2011.
        </li>
        <li>
          Linux bible". Christopher Negus. Indianapolis, IN. Wiley, 2011. ISBN: 9780470929988.
        </li>
        <li>
          Pro Linux System Administration". James Turnbull, Peter Lieverdink, Dennis Matotek. Berkeley, CA.
          Apress, 2009. ISBN: 978-1-4302-1912-5.
        </li>
        <li>
          Linux Network Administrator's Guide (Openbook)". Olaf Kirch, Terry Dawson. O'Reilly, 2000. ISBN:
          1-56592-400-2
        </li>
        <li>
          <a href="http://gondor.apana.org.au/~herbert/dash/">Web oficial de Dash</a>
        </li>
        <li>
          <a href="http://www.gnu.org/software/bash/manual/bashref.html">Manual de referencia de Bash</a>
        </li>
      </ul>
	  
	  <table class="tablaNormal">
        <tbody><tr>
          <td class="alerta">
            <p>
              <b>
                <span>Descarga de los shell-scripts de esta página</span>
              </b>
            </p>
            <p>
              Para que no tenga que escribir los scripts que se muestran en esta página a mano, puede descargarse dichos scripts así como la solución a los ejercicios propuestos en el fichero comprimido <a href="http://trajano.us.es/~fjfj/shell/shellscripts.tar.gz"><span class="shellscript">shellscripts.tar.gz</span></a>. Descomprímalo con el comando:
            </p><span class="shellscript">tar xfvz ./shellscripts.tar.gz </span>
			<p>
			</p><p>En el directorio <span class="shellscript">scripts</span> están los ejemplos y en el directorio <span class="shellscript">aplicacion</span> los ejercicios propuestos resueltos.
			</p>
			<p></p>
          </td>
        </tr>
		<tr>
          <td class="alerta">
            <p>
              <b>
                <span>Descarga en PDF (versión original)</span>
              </b>
            </p>
            <p>
              Puede descargarse también la versión original de este documento en formato PDF: <a href="http://trajano.us.es/~fjfj/shell/FAST_t3-practica.pdf"><span class="shellscript">FAST_t3-practica.pdf</span></a>.
			</p><p></p>
          </td>
        </tr>
	  </tbody></table>
	  
      <h1>
        <a id="_Toc444081196" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081196">2 Estructura básica de shell-scripts. Invocación</a>
      </h1>
      <p>En su forma más básica, un shell-script puede ser un simple fichero de texto que contenga uno o varios
      comandos. Para ayudar a la identificación del contenido a partir del nombre del archivo, es habitual que los shell scripts
      tengan la extensión ".sh", por lo que seguiremos este criterio (pero recuerde que es algo
      meramente informativo y opcional). Por ejemplo, el siguiente fichero sería un shell-script:</p>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">script.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">echo "Contenido carpeta personal:"
ls ~/
            </pre>
          </td>
        </tr>
      </tbody></table>
      <p>
        <span>&nbsp;</span>
      </p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>Compruebe que el fichero "script.sh" tiene permisos de ejecución generales (si no los tuviese, para
              asignárselos bastaría ejecutar "chmod +x script.sh").</li>
              <li>Invoque el script para que sea interpretado, usando por ejemplo el comando:
              <p>
                <span class="shellscript">cd ./script.sh</span>
              </p></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>
        <span>&nbsp;</span>
      </p>
      <p>Además de comandos, los shell-scripts pueden contener otros elementos, aportados por el shell para
      mejorar la funcionalidad de los scripts. De forma resumida, la estructura básica de un shell-script es la siguiente:</p>
      <table class="tablaNormal">
		<thead>
        <tr>
          <td>
            <p class="nombreFichero" style="margin-bottom: -1em;">
              <b>
                <span class="shellscript">script_ejemplo.sh</span>
              </b>
            </p>
          </td>
          <td>
            <p class="Encabezadodelatabla">
              <b>
                <span>&nbsp;</span>
              </b>
            </p>
          </td>
        </tr>
		</thead>
        <tbody><tr>
          <td>
            <pre class="shellscript">#!/bin/dash
# Esto no se interpreta
echo Hola
ps w
echo "Proceso lee el script: $$"
            </pre>
          </td>
          <td style="padding: 0;">
            <pre style="padding: 0;">&lt;-- Shebang
&lt;-- Comentarios
&lt;-- Contenido


            </pre>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <p>Como contenido del script pueden utilizarse múltiples elementos (comandos, variables, funciones,
      estructuras de control, comentarios,...) que se analizarán en el siguiente apartado.</p>
      <p>El "shebang" permite especificar el intérprete de comandos con el que deseamos que sea
      interpretado el resto del script cuando se usa invocación implícita (ver más adelante). La sintaxis de esta línea es la
      secuencia <span class="shellscript">#!</span> seguida del ejecutable del shell deseado, sobre lo que deben realizarse la siguientes
      advertencias:</p>
      <ul>
        <li>Es imprescindible que sea la primera línea del script, ya que, en caso contrario, sería interpretado como un comentario
        (comienza con el carácter <span class="shellscript">#</span>).</li>
        <li>Puede haber espacios entre 
        <span class="shellscript">#!</span> y el ejecutable del "shell".</li>
        <li>El shebang no es obligatorio (cuando se usa invocación implícita, si no se indica se intentará usar el mismo tipo de
        shell desde el que se ha invocado el script).</li>
      </ul>
      <table class="tablaNormal">
        <tbody><tr>
          <td class="alerta">
            <p>
              <b>
                <span>Sintaxis estricta</span>
              </b>
            </p>
            <p>
              <span>La sintaxis de los shell-scripts se caracteriza por ser bastante estricta en su escritura, especialmente en lo
              que se refiere a la inserción u omisión de espacios en blanco entre las palabras especiales. Tenga esto muy en cuenta
              a la hora de escribir los scripts que se proponen.</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p>
        <span>&nbsp;</span>
      </p>
      <p>
        <span>La utilización del shebang está condicionada por la forma en que sea invocado el shell-script, existiendo 3
        opciones:</span>
      </p>
      <ul>
        <li>
          <span>Explícita: escribiendo explícitamente qué shell se desea invocar y pasando como argumento el nombre del script,
          cargándose en memoria un nuevo proceso para dicho shell&nbsp; (subshell o proceso shell hijo del shell padre responsable
          de la línea de comandos desde la que se ha invocado el script). En este caso se ignora el shebang.</span>
        </li>
        <li>
          <span>Implícita: invocando al script como si fuera un ejecutable, lo que requiere asignar permisos de ejecución al
          script. Se lee el shebang para determinar qué shell deberá usarse para leer el script, cargándose en memoria un proceso
          hijo (subshell) para dicho shell (si el script no presenta shebang, para el subshell se utilizará el mismo tipo de shell
          que el encargado de la línea de comandos desde la que se ha hecho la invocación). Tenga en cuenta que los shell-scripts
          son ficheros de texto leídos por el intérprete de comandos, esto es, se interpretan, NO se ejecutan. La asignación del
          permiso de ejecución a un shell-script es una utilidad del sistema de ficheros para acelerar la invocación de scripts,
          pero cuyo funcionamiento interno es cargar un nuevo proceso de shell (subshell) para que éste interprete el
          script.</span>
        </li>
        <li>
        <span>Implícita con 
        <span class="shellscript">.</span> (equivale a importar): el script será interpretado por el mismo proceso del shell responsable de la línea de
        comandos desde la que se está invocando el script (luego aquí no se abre ningún subshell). Consecuentemente, en este caso
        también se ignora el shebang.</span></li>
      </ul>
      <p>
      <span>En los casos en los que se crean subshells, salvo que se fuerce lo contrario (con 
      <span class="shellscript">su -c</span> 
       por ejemplo), el subshell pertenecerá al mismo usuario al que pertenecía el shell padre que lo ha creado. El
      usuario al que pertenece el proceso shell que interpreta un script condiciona las operaciones que se podrán hacer desde
      dentro del script (por ejemplo, si el shell pertenece al usuario 
      <span class="shellscript">dit</span> 
      , el script no podrá modificar el fichero 
      <span class="shellscript">/etc/passwd</span> 
      , mientras que si el shell pertenece al superusuario 
      <span class="shellscript">root</span> 
      , sí podrá hacerlo). Tenga en cuenta este aspecto para determinar qué operaciones puede realizar dentro de un
      script, y con qué usuario debe invocarlo.</span></p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>En una consola de comandos ejecute el comando <span class="shellscript">ps w</span> y localice el proceso asociado al shell responsable de la línea de
              comandos desde la que está trabajando.</li>
              <li>Invoque dicho script mediante los distintos métodos de invocación. Para cada uno de ellos, analice la salida
              obtenida para determinar en cada caso cuál es el proceso shell que está interpretando el script, el usuario al que
              pertenece dicho proceso y si se ha abierto un subshell o no:
              <ul>
                <li>Explícita:
                <p>
				<span class="shellscript">/bin/sh script_ejemplo.sh</span></p>
				<p><span class="shellscript">/bin/dash script_ejemplo.sh</span></p>
				<p><span class="shellscript">/bin/bash script_ejemplo.sh</span></p>
                </li>
                <li>Implícita con ".":
                <p>
                  <span class="shellscript">.&nbsp; script_ejemplo.sh</span>
                </p></li>
                <li>Implícita: compruebe que el script tiene permiso de ejecución y ejecútelo con:
                <p>
                  <span class="shellscript">./script_ejemplo.sh</span>
                </p>
                <p>Modifique el script eliminando el shebang, y vuelva a ejecutarlo. Analice si hay alguna
                diferencia respecto a la ejecución anterior.</p></li>
              </ul></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>
        <span>&nbsp;</span>
      </p>
      <p>
      <span>Conforme se ha indicado en la introducción, si bien tanto bash como dash siguen el estándar POSIX, especialmente bash
      añade múltiples extensiones particulares, no soportadas por otros shells como dash. Consecuentemente, cada vez que diseñemos
      un script deberemos tener en cuenta el shell o shells que lo soportan, asegurando que sea invocado por uno de ellos. Para que
      se haga una idea de la importancia de este aspecto, considere los dos scripts siguientes, basados en el uso de la estructura
      
      <span class="shellscript">for</span> 
       (que se usará más adelante):</span></p>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">script_estandar.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/sh for VAR in 0 1 2 3
do
&nbsp;&nbsp; echo $VAR
done
            </pre>
          </td>
        </tr>
      </tbody></table>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">script_bash.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/bash
for ((VAR=0 ; VAR&lt;4 ; VAR++ ))
do
&nbsp;&nbsp; echo $VAR
done
            </pre>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <p>
      <span>Ambos scripts realizan la misma funcionalidad, pero 
      <span class="shellscript">script_estandar.sh</span> 
       está escrito bajo la sintaxis POSIX, mientras que 
      <span class="shellscript">script_bash.sh</span> 
       utiliza una sintaxis no estándar soportada por bash.</span></p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>Invoque el guión <span class="shellscript">script_estandar.sh</span> (recuerde que debe disponer de ellos ya creados en el directorio <span class="shellscript">scripts/</span>) mediante los siguientes comandos, debiendo comprobar
              que todas funcionan correctamente y con igual resultado (la primera y segunda llamada realmente son la misma, usando
              el shell <span class="shellscript">dash</span>):
              <p>
                <span class="shellscript">/bin/sh&nbsp;&nbsp;&nbsp; script_estandar.sh</span>
              </p>
              <p>
                <span class="shellscript">/bin/dash&nbsp; script_estandar.sh</span>
              </p>
              <p>
                <span class="shellscript">/bin/bash&nbsp; script_estandar.sh</span>
              </p>			  
			  </li>
              <li>Ahora invoque el guión <span class="shellscript">script_bash.sh</span> mediante los siguientes comandos:
              <p>
                <span class="shellscript">/bin/dash&nbsp; script_bash.sh</span>
              </p>
              <p>
                <span class="shellscript">/bin/bash&nbsp; script_bash.sh</span>
              </p>			  
              <p>Podrá comprobar cómo, debido a la sintaxis no estándar del script, la segunda invocación funciona, pero la primera
              (que emplea dash) da un error de sintaxis.</p></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <h1>
        <a id="_Toc444081197" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081197">3 Sintaxis de Shell-scripts</a>
      </h1>
      <p>En este apartado se describe el lenguaje de comandos shell definido en el estándar POSIX. Veremos el
      funcionamiento general del shell, así como su sintaxis. Puede encontrar la descripción detallada del estándar POSIX en el
      siguiente enlace:
        <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html">POSIX Shell Command Language</a>
      </p>
      <p>Aquí se resumen las características más utilizadas. Se recomienda acudir al <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html">estándar</a> para
      obtener una descripción más detallada y exhaustiva.</p>
      <h2>
        <a id="_Toc444081198" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081198">3.1 Funcionamiento general del shell</a>
      </h2>
      <p>El lenguaje shell es un lenguaje interpretado, en el que se leen líneas de texto (terminadas en \n), se
      analizan y se procesan. Las líneas a interpretar son leídas de:</p>
      <ul>
        <li>
          <span>La entrada estándar (teclado por defecto). En este caso el shell se dice que es un shell interactivo.</span>
        </li>
        <li>
          <span>Un fichero shell-script.</span>
        </li>
        <li>
        <span>Los argumentos, con la opción 
        <span class="shellscript">-c</span> 
         al ejecutar el shell. Ejemplo:</span> 
        <span class="shellscript">bash –c "ls –l"</span></li>
      </ul>
      <p>
      <span>Con las líneas</span> leídas, el shell realiza los siguientes pasos (en este orden):</p>
      <ol>
        <li>
          <span>Se dividen las líneas en distintos elementos: palabras y operadores. Los elementos se separan usando espacios,
          tabuladores y operadores. El carácter <span class="shellscript">#</span> sirve para incluir un comentario, que se elimina del
          procesamiento.</span>
        </li>
        <li>
          <span>Se distingue entre comandos simples, comandos compuestos y definiciones de función.</span>
        </li>
        <li>
          <span>Se realizan distintas expansiones y sustituciones (ver más adelante). Se detecta el comando a ejecutar y los
          argumentos que se le van a pasar.</span>
        </li>
        <li>
          <span>Se realizan las redirecciones de entrada/salida y se eliminan los elementos asociados a las redirecciones de la
          lista de argumentos. Las redirecciones de entrada/salida ya se han explicado en un tema anterior (si desea ampliar
          información, consulte el anexo).</span>
        </li>
        <li>
          <span>Se ejecuta el elemento ejecutable, que podría ser una función, un comando interno del shell, un fichero ejecutable
          o un shell-script, pasando los argumentos como parámetros posicionales (ver más adelante).</span>
        </li>
        <li>
          <span>Opcionalmente, se espera a que termine el comando y se guarda el código de salida.</span>
        </li>
      </ol>
      <table class="tablaNormal">
        <tbody><tr>
          <td class="alerta">
            <p>
              <b>
                <span>Advertencia</span>
              </b>
            </p>
            <p>
              <span>A lo largo de la memoria se utilizará la palabra "ejecutar" para referirse a la ejecución de un
              programa binario (un programa compilado, por ejemplo), al inicio de la interpretación de un script o a la invocación
              de una función o comando interno. Se considerarán, por tanto, elementos ejecutables, programas binarios y scripts
              (con el permiso de ejecución), comandos internos y funciones.</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <p>Cuando se escriben comandos desde el teclado y se intenta introducir un elemento que está formado por
      más de una línea, una vez que teclee la primera línea y pulse <span class="shellscript">Intro</span>, el shell mostrará el indicador secundario de
      petición de orden <span class="shellscript">&gt;</span> (en lugar del prompt), solicitándole que continúe escribiendo el elemento.
      Cuando el intérprete dé por concluida la introducción del elemento, la interpretará, volviendo a mostrar el prompt de la
      línea de comandos. Si utiliza el cursor <span class="shellscript">↑</span> para intentar ver el comando introducido, en general verá cómo el shell
      ha rescrito la entrada para aplicarle la sintaxis con la que todo el elemento es escrito en una sola línea. Si desea cancelar
      la introducción de una línea (o líneas) sin necesidad de borrar lo que lleva escrito, puede pulsar Ctrl-C.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
	    <p>Escriba el contenido del script 
            <span class="shellscript">script_estandar.sh</span> visto en el apartado 2 directamente en una consola de
            comandos.</p>
	    <p>&nbsp;</p>
          </td>
        </tr>
      </tbody></table>
      <h2>
        <a id="_Toc444081199" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081199">3.2 Entrecomillado y carácter de escape</a>
      </h2>
      <p>El shell tiene una lista de caracteres que trata de manera especial (operadores) y una serie de palabras
      reservadas (palabras que tienen un significado especial para el Shell). Puede ver un listado de caracteres especiales y
      palabras reservadas en los apartados <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_02">2.2</a> y <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_04">2.4</a> del estándar.</p>
      <p>Cuando queremos utilizar un carácter especial del shell o una palabra reservada del lenguaje sin que sea
      interpretada como tal o prevenir una expansión o sustitución indeseada (las expansiones y sustituciones se verán en un
      apartado posterior) es necesario indicárselo al shell mediante las comillas (simples o dobles) o el carácter de escape. Por
      ejemplo, para escribir el nombre de un fichero que contenga espacios, para pasar el símbolo 
      <span class="shellscript">&lt;</span> como argumento a un programa.</p>
      <ul>
        <li>
        <span>El carácter de escape 
        <span class="shellscript">\</span> 
        : indica que el siguiente carácter debe preservar su valor literal. El carácter de escape se elimina de la línea una
        vez procesado. Si aparece al final de una línea, significa "continuación de línea" e indica que el comando
        continúa en la siguiente línea (puede ser utilizado para dividir líneas muy largas).</span></li>
        <li>
        <span>Comillas simples 
        <span class="shellscript">' '</span> 
        : todo texto ‘entrecomillado’ con comillas simples mantendrá su valor literal, no se producirá ninguna expansión ni
        sustitución y será considerado como una única palabra.</span></li>
        <li>
        <span>Comillas dobles 
        <span class="shellscript">"</span>: es equivalente a usar comillas simples, salvo que en este caso sí se hacen expansiones y sustituciones (todas
        menos las expansiones de tilde y ruta y la sustitución de alias que veremos más adelante).</span></li>
      </ul>
      <p>
      <span>El entrecomillado de una cadena vacía (</span> 
      <span class="shellscript">''</span> 
      <span>o</span> 
      <span class="shellscript">"</span>) genera una palabra vacía (palabra que no tiene ningún carácter).</p>
      <p>Vea el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_02">2.2</a> del estándar para obtener información detallada.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>Ejecute los siguientes comandos en el terminal y analice los resultados:<br> 
              <pre class="shellscript">cd
echo $PWD
echo \$PWD
echo '$PWD'
echo "$PWD"
echo hola \&gt; a y b
#se crea el fichero a
echo hola &gt; a y b&nbsp;&nbsp;&nbsp;
ls
cat a
#se crea el fichero 'a y b'
echo hola &gt;"a y b"&nbsp;&nbsp; 
ls
cat a\ y\ b</pre></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <h2>
        <a id="_Toc444081200" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081200">3.3 Parámetros y variables</a>
      </h2>
      <p>Como en cualquier lenguaje de programación, en el lenguaje shell se pueden crear y utilizar variables,
      que aquí se llaman parámetros. Existen varios tipos de parámetros:</p>
      <ol>
        <li>Si el nombre es un número se denominan parámetros posicionales.</li>
        <li>Si el nombre es un carácter especial se denominan parámetros especiales.</li>
        <li>El resto se denominan simplemente variables.</li>
      </ol>
      <p>A continuación se detallan cada uno de estos tipos. Vea el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_05">2.5</a> del estándar para obtener más
      información.</p>
      <h3>
        <a id="_Toc444081201" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081201">3.3.1 Variables</a>
      </h3>
      <p>El shell permite realizar las siguientes operaciones básicas con las variables:</p>
      <table class="tablaNormal tablaDefiniciones">
        <tbody><tr>
          <td class="celdaDestacada">
            <p class="Contenidodelatabla centrado">
              <b>
                <span>Sólo Definición</span>
              </b>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span class="shellscript">VAR=""</span>
            </p>
            <p class="Contenidodelatabla">
              <span class="shellscript">VAR=</span>
            </p>
          </td>
        </tr>
        <tr>
          <td class="celdaDestacada">
            <p class="Contenidodelatabla centrado">
              <b>
                <span>Definición y/o Inicialización/Modificación</span>
              </b>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span class="shellscript">VAR=valor</span>
            </p>
          </td>
        </tr>
        <tr>
          <td class="celdaDestacada">
            <p class="Contenidodelatabla centrado">
              <b>
                <span>Expansión (Acceso a Valor)</span>
              </b>
            </p>
          </td>
          <td>
			<p class="Contenidodelatabla">
              <span class="shellscript">$VAR</span>
            </p>
			<p class="Contenidodelatabla">
              <span class="shellscript">${VAR}</span>
            </p>
 
          </td>
        </tr>
        <tr>
          <td class="celdaDestacada">
            <p class="Contenidodelatabla centrado">
              <b>
                <span>Eliminación de la variable</span>
              </b>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span class="shellscript">unset VAR</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <p>Sobre ello deben realizarse las siguientes observaciones respecto a:</p>
      <ol>
        <li>Definición y uso:
        <ul>
          <li>Las variables sólo existen en el proceso shell en que son definidas (locales al proceso).</li>
          <li>Las variables sólo son accesibles desde el momento de su definición hacia abajo del script, esto es, siempre deben
          definirse primero e invocarse después (no puede usarse una variable que es definida más adelante). Pueden utilizarse
          también dentro de funciones (ver más adelante) aunque se hayan declarado fuera de ellas. En el estándar POSIX todas las
          variables son globales, aunque existen variantes (como 
          <span class="shellscript">bash</span>) que permiten la creación de variables locales a las funciones.</li>
        </ul>
        <p>No es necesario definir las variables previamente a su uso, ya que se crean al asignarles la primera vez un valor. Al
        definir una variable sin inicialización, su valor por omisión es la cadena nula, esto es, las siguientes entradas son
        equivalentes:</p>
        <p>
          <span class="shellscript">VAR=</span>
        </p>
        <p>
          <span class="shellscript">VAR=""</span>
        </p>
        <p>Con el comando <span class="shellscript">set</span> (sin argumentos) puede ver todas las variables (y funciones) definidas en el shell actual.</p></li>
        <li>Nombrado: téngase en cuenta que Linux es "case sensitive" (sensible a mayúsculas y minúsculas) en general, lo
        que incluye el nombre de las variable. Así, 
        <span class="shellscript">VAR</span> y 
        <span class="shellscript">var</span> serán tomadas como dos variables independientes 
        <span>. Para el nombre de una variable puede usarse</span> 
        <span>:</span>
        <ul>
          <li>1er carácter: una letra o el carácter de subrayado 
          <span class="shellscript">_</span>.</li>
          <li>2º y posteriores caracteres: una letra, dígito o el carácter de subrayado.</li>
        </ul></li>
        <li>Inicialización/Modificación del valor de una variable:
        <ul>
          <li>Es importante no incluir ningún espacio ni antes ni después del signo <span class="shellscript">=</span>. Si se hace, el shell intentará
          interpretar el nombre de la variable como un comando (recuerde que la sintaxis del shell es especialmente estricta en lo
          que a espacios se refiere).</li>
          <li>El valor de una variable siempre es tomado por el shell como una cadena de caracteres.</li>
          <li>Si el valor de una variable contiene caracteres especiales, espacios, u otros elementos que puedan ser
          malinterpretados por el shell, tendrá que ir entrecomillado o deberá incluir el carácter de escape donde sea
          necesario.</li>
        </ul></li>
        <li>Expansión de una variable: el uso de las llaves 
        <span class="shellscript">{}</span> sólo es necesario si justo tras el nombre de la variable se desean escribir
        más caracteres, sin añadir ningún espacio antes. Se verá más adelante con más detalle.</li>
      </ol>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Mire el contenido del script <span class="shellscript">script_variables.sh</span>, que deberá contener lo
            siguiente:</p>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script_variables.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">echo "Mal definida":
echo "(orden no encontrada)":
VAR = 1
echo "Variables bien definidas:"
VAR=1
VAR1=2
var=3
echo "Variables: $VAR $VAR1 $var"
echo "Variable VAR: $VAR"
echo "Variable VAR1: $VAR1"
echo "VAR seguida de 1: ${VAR}1"
echo "Comillas dobles: $VAR"
echo 'Comillas simples: $VAR'
echo "Valor: $VAR-1"
                  </pre>
                </td>
              </tr>
            </tbody></table>
            <p>Compruebe que dispone del permiso de ejecución general. Invóquelo y analice su funcionamiento.</p>
          </td>
        </tr>
      </tbody></table>
      <h4>
        <a id="_Toc444081202" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081202">3.3.1.1 Variables del shell</a>
      </h4>
      <p>Existe un conjunto de variables que afectan al funcionamiento del shell. Muchas ya han sido analizadas
      en temas anteriores, por ejemplo: <span class="shellscript">HOME</span>, <span class="shellscript">PATH</span>, <span class="shellscript">LANG</span>,... Puede volver a ver una descripción de ellas en el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_05_03">2.5.3</a> del
      estándar.</p>
      <p>Aquí vamos a destacar la variable <span class="shellscript">IFS</span> (Input Field Separators). El valor de esta variable es una lista
      de caracteres que se emplearán en el proceso de división de campos realizado tras el proceso de expansión (que se verá más
      adelante, en el apartado 3.4) y por el comando <span class="shellscript">read</span> (ver el apartado 3.8.1 de comandos internos). El valor por
      defecto es <span class="shellscript">&lt;espacio&gt;&lt;tab&gt;&lt;nueva-línea&gt;</span>. Podrá ver un ejemplo de uso de esta variable cuando
      realice los ejercicios propuestos (ver solución a script_user.sh).</p>
      <h3>
        <a id="_Toc444081203" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081203">3.3.2 Parámetros posicionales</a>
      </h3>
      <p>Son los parámetros de la línea de comandos con la que se ha invocado al script (equivalen a la variable 
      <span class="shellscript">argv</span> de C). Están denotados por un número y para obtener su valor se emplea 
      <span class="shellscript">$X</span> o 
      <span class="shellscript">${X}</span> para los parámetros del 1 al 9 y 
      <span class="shellscript">${X}</span> para parámetros mayores (números de más de un dígito). Se pueden modificar con los
      comando 
      <span class="shellscript">set</span> (los crea) y 
      <span class="shellscript">shift</span> (los desplaza de posición).</p>
      <h3>
        <a id="_Toc444081204" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081204">3.3.3 Parámetros especiales</a>
      </h3>
      <p>Son parámetros identificados por un carácter especial creados por el Shell y cuyo valor no puede ser
      modificado directamente. En esta tabla se muestran los parámetros especiales definidos en el estándar:</p>
      <table class="tablaNormal tablaDefiniciones">
        <tbody><tr>
          <td class="celdaDestacada">
            <p class="Encabezadodelatabla centrado">
              <b>
                <span>Parámetro especial</span>
              </b>
            </p>
          </td>
          <td class="celdaDestacada">
            <p class="Encabezadodelatabla centrado">
              <b>
                <span>Valor</span>
              </b>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$*</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Se expande a todos los parámetros posicionales desde el 1. Si se usa dentro de comillas dobles, se expande como
              una única palabra formada por los parámetros posicionales separados por el primer carácter de la variable <span class="shellscript">IFS</span> (si la
              variable <span class="shellscript">IFS</span> no está definida, se usa el espacio como separador y si está definida a la cadena nula, los campos se
              concatenan).</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$@</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Se expande a todos los parámetros posicionales desde el 1, como campos separados, incluso aunque se use dentro
              de comillas dobles.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$0</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Nombre del shell o shell-script que se está ejecutando.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
            <span class="shellscript">$-</span> 
            <span>(guion)</span></p>
          </td>
          <td>
            <p class="Contenidodelatabla">
            <span>Opciones actuales del shell (modificables con el comando set). Consulte las opciones disponibles con el comando
            
            <span class="shellscript">man dash</span>
            
            .</span></p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$#</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Nº de argumentos pasados al script (no incluye el nombre del script).</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$?</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Valor devuelto por el último comando, script, función o sentencia de control invocado. Recuerde que, en
              general, cualquier comando devuelve un valor. Usualmente, cuando un comando encuentra un error devuelve un valor
              distinto de cero.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$$</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>PID del proceso shell que está interpretando el script.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">$!</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>PID del último proceso puesto en segundo plano.</span>
            </p>
          </td>
        </tr>
      </tbody></table>
	  <p></p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Mire el contenido del script <span class="shellscript">script_var-shell.sh</span>, que deberá contener lo siguiente:</p>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script_var-shell.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/sh
echo \$@=$@
echo \$*=$*
echo \$0=$0
echo \$1=$1
echo \$2=$2
echo Cambio parametros posicionales
set uno dos tres
echo \$1=$1
echo \$2=$2
echo Desplazo
shift
echo \$1=$1
echo \$2=$2
echo \$-=$-
echo \$#=$#
echo \$?=$?
firefox &amp;
ps w
echo \$$=$$
echo \$!=$!
                  </pre>
                </td>
              </tr>
            </tbody></table>
            <p>Compruebe que dispone del permiso de ejecución. Invóquelo el comando y analice la salida:</p>
            <p>
              <span class="shellscript">./script_var-shell.sh arg1 arg2</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <h3>
        <a id="_Toc444081205" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081205">3.3.4 Exportación de variables</a>
      </h3>
      <p>Cuando un proceso (proceso padre, como por ejemplo el shell) ejecuta otro proceso (proceso hijo, otro
      programa o script), el proceso padre, además de los parámetros habituales ( 
      <span class="shellscript">argc</span> y 
      <span class="shellscript">argv</span> en C), le pasa un conjunto de variables de entorno al proceso hijo (cada lenguaje
      de programación tiene su método propio para obtenerlas y modificarlas). Las variables de entorno pasadas pueden ser
      utilizadas por el proceso hijo para modificar su comportamiento. Por ejemplo, un programa en C puede usar la función <span class="shellscript">getenv</span> declarada en biblioteca estándar 
      <span class="shellscript">stdlib.h</span> para obtener dichas variables (puede obtener más información ejecutando <span class="shellscript">man getenv</span>).</p>
      <p>El comando interno del shell <span class="shellscript">export</span> permite que una variable (previamente definida o no) sea configurada para
      que su valor sea copiado a los procesos hijos que sean creados desde el shell actual (por ejemplo otros shell). Presenta la
      sintaxis:</p>
      <p>
        <span class="shellscript">export VAR</span>
      </p>
      <p>
        <span class="shellscript">export VAR=valor</span>
      </p>      <p>En este último caso, sí es posible añadir un espacio antes o después del signo <span class="shellscript">=</span>.</p>
      <p>Debe advertirse que "exportación" significa "paso de parámetros por valor", esto es,
      en el proceso hijo se creará una variable de igual nombre que en el shell padre, y con igual valor, pero serán variables
      independientes (esto es, la modificación de valor de la variable en el proceso hijo no afectará al valor de la variable en el
      shell padre). 
      <b>El proceso hijo no puede crear ni modificar variables del proceso padre</b>.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Mire el contenido de los siguientes scripts en su sistema:</p>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script_padre.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/bash
export VAR=a
echo $VAR
ps w
./script_hijo.sh
echo $VAR</pre>
                </td>
              </tr>
            </tbody></table>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script_hijo.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/sh
echo $VAR
VAR=b
echo $VAR
ps w</pre>
                </td>
              </tr>
            </tbody></table>
            <p>Compruebe que dispone del permiso de ejecución. Ejecute el comando:</p>
            <p>
              <span class="shellscript">./script_padre.sh</span>
            </p>
            <p>Analice el resultado.</p>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <p>No debe confundirse la exportación con la invocación de shell-scripts mediante el mecanismo implícito
      basado en <span class="shellscript">.</span>. En este caso no hay ninguna copia de variables por valor, simplemente el script
      invocado es interpretado por el mismo shell.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Mire el contenido de los siguientes scripts en su sistema:</p>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script1.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/bash
VAR=a
echo $VAR
ps w
. script2.sh
echo $VAR</pre>
                </td>
              </tr>
            </tbody></table>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script2.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/sh
echo $VAR
VAR=b
echo $VAR
ps w</pre>
                </td>
              </tr>
            </tbody></table>
            <p>Compruebe que dispone del permiso de ejecución general. Ejecute el siguiente commando y analice el
            resultado:</p>
            <p>
              <span class="shellscript">./script1.sh</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p>
        <span>&nbsp;</span>
      </p>
      <p>En los S.O.'s Linux suele ser habitual encontrar scripts que se dedican exclusivamente a contener la
      inicialización de un conjunto de variables, o la definición de un conjunto de funciones. Otros scripts del sistema hacen uso
      del mecanismo de invocación implícito basado en <span class="shellscript">.</span>, para cargar o importar las variables o funciones definidas en dichos
      scripts.</p>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">cont_func.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/sh
fun1(){...}
fun2(){...}
#...
</pre>
          </td>
        </tr>
      </tbody></table>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">cont_var.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/sh
VARa=1
VARb=2
#...
</pre>
          </td>
        </tr>
      </tbody></table>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">script_sistema.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/sh
. /dir/cont_var.sh
. /dir2/cont_fun.sh
fun1 $VARb
#...
</pre>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Por ejemplo, visualice el contenido del script del sistema encargado del arranque de los servicios
            <span class="shellscript">/etc/init.d/rc</span>. Observe cómo contiene las líneas:</p>
            <p>
              <span class="shellscript">.&nbsp; /etc/default/rcS</span>
            </p>
            <p>
              <span class="shellscript">.&nbsp; /lib/lsb/init-functions</span>
            </p>
            <p>Visualice el contenido de esos archivos <span class="shellscript">rcS</span> e <span class="shellscript">init-functions</span> y compruebe cómo sólo contienen definiciones de variables y funciones (la sintaxis para la definición de las funciones se analizará más adelante),
            respectivamente. De hecho, todos los ficheros de la carpeta <span class="shellscript">/etc/default/</span> son scripts dedicados exclusivamente a
	contener la inicialización de variables, siendo importadas desde otros scripts del sistema. Por ejemplo, observe cómo:</p>
            <ul>
              <li>La variable <span class="shellscript">VERBOSE</span> es inicializada en <span class="shellscript">rcS</span> y luego es usada por <span class="shellscript">rc</span>.</li>
              <li>La función <span class="shellscript">log_failure_msg()</span> es definida en <span class="shellscript">init-functions</span> y luego es usada&nbsp; por <span class="shellscript">rc</span>.</li>
            </ul>
          </td>
        </tr>
      </tbody></table>
      <h2>
        <a id="_Toc444081206" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081206">3.4 Expansiones y sustituciones</a>
      </h2>
      <p>Como se vio en el apartado de funcionamiento general del shell (apartado 3.1), en un paso previo a la
      ejecución del elemento ejecutable se realizan una serie de expansiones y sustituciones. En este apartado se describe cuáles
      son y cómo se realizan. Puede ver una descripción detallada en el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06">2.6</a> del estándar.</p>
      <p>Existen los siguientes tipos de expansiones y sustituciones (que desarrollaremos más adelante):</p>
      <ol>
        <li>Expansión de ~ (virgulilla o tilde de la ñ).</li>
        <li>Expansión de parámetros o variables.</li>
        <li>Sustitución de comando.</li>
        <li>Expansión aritmética.</li>
        <li>Expansión de ruta.</li>
      </ol>
      <p>Aparte de estas expansiones está el concepto de alias (ver apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_03_01">2.3.1</a> del estándar) que se utiliza
      para crear sinónimos de comandos y sólo se realiza en el elemento ejecutable de la línea antes de cualquier otra expansión o
      sustitución. Su utilización es muy limitada y puede conseguirse un comportamiento similar usando funciones que permiten
      además parámetros (las funciones se verán más adelante). Puede ver los alias definidos usando el comando <span class="shellscript">alias</span>. Puede ver ejemplos de definición de alias en el fichero 
      <span class="shellscript">~/.bashrc</span>.</p>
      <p>El orden de ejecución de estas expansiones es el siguiente:</p>
      <ol>
        <li>Primero se hacen en orden las siguientes expansiones:
        <ul>
          <li>Expansión de ~.</li>
          <li>Expansión de parámetros o variables.</li>
          <li>Sustitución de comando.</li>
          <li>Expansión aritmética.</li>
        </ul></li>
        <li>Los campos generados en el primer paso son divididos utilizando como separadores los caracteres de la variable <span class="shellscript">IFS</span>. Si
        la variable <span class="shellscript">IFS</span> es nula (cadena nula) no se produce la división. Si la variable no está definida, se utilizan por defecto
        los caracteres espacio, tabulador y nueva línea.</li>
        <li>Se realiza a continuación la última expansión:</li>
        <li>Expansión de ruta.</li>
        <li>Por último, se eliminan las comillas simples o dobles que existan y se utilicen como tal (no se eliminan las comillas
        que hayan perdido su significado especial, por ejemplo usando el carácter de escape).</li>
      </ol>
      <p>Puede utilizar las expansiones en cualquier ubicación donde se pueda usar una cadena de texto (incluido
      el nombre de comandos), exceptuando las palabras reservadas del lenguaje (<span class="shellscript">if</span>, <span class="shellscript">else</span>, …).</p>
      <h3>
        <a id="_Toc444081207" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081207">3.4.1 Expansión de ~</a>
      </h3>
      <p>Las apariciones de la virgulilla (o tilde de la ñ) dentro de una línea, que no se encuentren
      entrecomilladas, se expanden de la siguiente manera:</p>
      <table class="tablaNormal tablaDefiniciones">
        <tbody><tr>
          <td class="celdaDestacada">
            <p class="Encabezadodelatabla centrado">
              <b>
                <span>Variables</span>
              </b>
            </p>
          </td>
          <td class="celdaDestacada">
            <p class="Encabezadodelatabla centrado">
              <b>
                <span>Valor</span>
              </b>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">~</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Se expande al valor de la variable <span class="shellscript">HOME</span></span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla centrado">
              <span class="shellscript">~login</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>Si "login" es un nombre de usuario del sistema, se expande a la ruta absoluta del directorio de
              inicio de sesión de ese usuario. Si no, no se expande.</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Comente la línea del script <span class="shellscript">script_var-shell.sh</span>, visto en el apartado 3.3, donde aparece la palabra
            "firefox". Ejecute los siguientes comandos observando el valor de las variables posicionales:</p>
            <p>
              <span class="shellscript">./script_var-shell.sh ~ ~root</span>
            </p>
            <p>
              <span class="shellscript">./script_var-shell.sh ~noexiste ~dit</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <h3>
        <a id="_Toc444081208" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081208">3.4.2 Expansión de parámetros y variables</a>
      </h3>
      <p>El formato general para incluir una expansión de variables o parámetros, como se ha visto en apartados
      anteriores es:</p>
      <p>
        <span class="shellscript">${PAR}</span>
      </p>
      <p>Las llaves pueden omitirse, salvo cuando se trate de un parámetro posicional con más de un dígito o
      cuando se quiera separar el nombre de la variable de otros caracteres. Por ejemplo:</p>
      <p>
        <span class="shellscript">echo $PAR&nbsp;&nbsp; #puede omitirse</span>
      </p>
      <p>
        <span class="shellscript">echo ${10}&nbsp;&nbsp; #no puede omitirse</span>
      </p>
      <p>
        <span class="shellscript">${PAR}TEXTO&nbsp; #no se omite</span>
      </p>
      <p>Si la expansión de parámetros ocurre dentro de comillas dobles, sobre el resultado no se realizará la
      expansión de ruta ni la división de campos (pasos b y c). En el caso del parámetro especial <span class="shellscript">@</span>, se hace la división de campos
      siempre.</p>
      <p>Aparte de este formato general, se pueden utilizar otros formatos que permiten establecer valores por
      defecto, comprobar si la variable está definida, eliminar sufijos y prefijos, contar el número de caracteres, etc. Puede ver
      la lista de formatos junto con ejemplos en el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_02">2.6.2</a> del estándar. Por ejemplo, los siguientes:</p>
      <table class="tablaNormal tablaDefiniciones">
        <tbody><tr>
          <td>
            <p class="Contenidodelatabla shellscript centrado">${PAR:-alternativo}</p>
          </td>
          <td>
            <p class="Contenidodelatabla centrado">
              <span>Valor de la variable. Si la variable no tiene ningún valor, la construcción se sustituye por el valor
              <span class="shellscript">alternativo</span>.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript centrado">${PAR:=alternativo}</p>
          </td>
          <td>
            <p class="Contenidodelatabla centrado">
              <span>Ídem al anterior, pero asignando el valor <span class="shellscript">alternativo</span> a la variable.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript centrado">${PAR%sufijo}</p>
          </td>
          <td>
            <p class="Contenidodelatabla centrado">
              <span>Elimina el <span class="shellscript">sufijo</span> más pequeño del valor de la variable. <span class="shellscript">sufijo</span> es un patrón como los
              utilizados en la expansión de ruta. Si en vez de <span class="shellscript">%</span> se pone <span class="shellscript">%%</span> se elimina el <span class="shellscript">sufijo</span> más grande.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript centrado">${PAR#prefijo}</p>
          </td>
          <td>
            <p class="Contenidodelatabla centrado">
              <span>Elimina el <span class="shellscript">prefijo</span> más pequeño del valor de la variable. <span class="shellscript">prefijo</span> es un patrón como los
              utilizados en la expansión de ruta. Si en vez de <span class="shellscript">#</span> se pone <span class="shellscript">##</span> se elimina el <span class="shellscript">prefijo</span> más grande.</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <p>Los siguientes scripts muestran un posible ejemplo de ambas construcciones:</p>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">script_expansion1.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/sh
VAR=1
echo $VAR
unset VAR
echo ${VAR:-2}
echo $VAR
FICH=fichero.c
echo ${FICH%.c}.o
</pre>
          </td>
        </tr>
      </tbody></table>
      <table class="tablaNormal">
        <thead>
          <tr>
            <td>
              <p class="nombreFichero">
                <b>
                  <span class="shellscript">script_expansion2.sh</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td class="contenidoFichero">
            <pre class="shellscript">#!/bin/sh
VAR=1
echo $VAR
unset VAR
echo ${VAR:=2}
echo $VAR
FICH=/usr/bin/prueba
echo ${FICH##*/}
</pre>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
			<p><br>Mire el contenido de los scripts anteriores en su sistema, invóquelos y analice los
            resultados.<br>&nbsp;</p>
          </td>
        </tr>
      </tbody></table>
      <h3>
        <a id="_Toc444081209" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081209">3.4.3 Sustitución de comando</a>
      </h3>
      <p>Permite que la salida estándar de un programa se utilice como parte de la línea que se va a
      interpretar.</p>
      <p>Existen dos opciones, con el mismo funcionamiento:</p>
      <p>
        <span class="shellscript">$(comando)</span>
      </p>
      <p>
        <span class="shellscript">`comando`</span>
      </p>
      <p>En el segundo caso se está utilizando la tilde francesa o acento grave, que no debe confundirse con las
      comillas simples. Para escribirla, hay que pulsar la tecla correspondiente a <span class="shellscript">`</span> y pulsar espacio.</p>
      <p>El shell ejecutará <span class="shellscript">comando</span>, capturará su salida estándar y sustituirá <span class="shellscript">$(comando)</span> por la
      salida capturada.</p>
      <p>Por ejemplo, para almacenar en una variable el nombre de todos los ficheros con extensión .sh del
      directorio actual, podría escribir:</p>
      <p>
        <span class="shellscript">VAR=`ls *.sh`</span>
      </p>
      <p>O, por ejemplo, para matar el proceso con nombre <span class="shellscript">firefox-bin</span>, podría usar:</p>
      <p>
        <span class="shellscript">kill -9 $(pidof firefox-bin)</span>
      </p>
      <p>&nbsp;</p>
      <h3>
        <a id="_Toc444081210" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081210">3.4.4 Expansión aritmética</a>
      </h3>
      <p>El formato para realizar una expansión aritmética es el siguiente:</p>
      <p>
        <span class="shellscript">$((expresión))</span>
      </p>
      <p>
        Permite evaluar las cadenas indicadas en la expresión como enteros, admitiendo gran parte de los operadores usados en
        el lenguaje C, pudiendo usar paréntesis como parte de la expresión y el signo <span class="shellscript">-</span> para números negativos (a las
        cadenas que contengan letras se les asigna el valor <span class="shellscript">0</span>). Tras la evaluación aritmética, el resultado vuelve a
        ser convertido a una cadena.
		La conversión de un número a un carácter puede realizarse con <span class="shellscript">$'\xxx'</span> (en <span class="shellscript">bash</span>) o con <span class="shellscript">'\xxx'</span> (en <span class="shellscript">dash</span>), ambos con comillas simples,
		pero ello no está recogido en el estándar POSIX.
      </p>
      <p>
        <span>Si se usan variables en la expresión, no es necesario que vayan precedidas por el carácter <span class="shellscript">$</span> si ya contienen un valor
        entero válido (sí es necesario para los parámetros posicionales y especiales).</span>
      </p>
      <p>Puede ver más detalles en el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_04">2.6.4</a> del estándar.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Mire el contenido del script <span class="shellscript">script_expansion3.sh</span>, que deberá contener lo siguiente:</p>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script_expansion3.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/sh
VAR=1
VAR=$VAR+1
echo $VAR
RES1=$(($VAR))+1
echo $RES1
VAR=1
RES2=$((VAR+1)) #VAR no necesita $
echo $RES2
VARb=b
echo $(($VARb+1)) #VARb necesita $</pre>
                </td>
              </tr>
            </tbody></table>
            <p>Compruebe que dispone del permiso de ejecución. Invóquelo mediante el comando:</p>
            <p>
              <span class="shellscript">./script_expansion3.sh</span>
            </p>
            <p>Analice el resultado.</p>
          </td>
        </tr>
      </tbody></table>
      <h3>
        <a id="_Toc444081211" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081211">3.4.5 Expansión de ruta</a>
      </h3>
      <p>Los campos que incluyan los caracteres <span class="shellscript">*</span>, <span class="shellscript">?</span>y <span class="shellscript">[</span> (asterisco,
      interrogación y apertura de corchetes) no entrecomillados serán sustituidos por la lista de ficheros que cumplan ese patrón.
      Si no hay ningún fichero con ese patrón no se sustituye nada. El uso de estos caracteres ya se ha utilizado en otros cursos. Puede ver más detalles en el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13">2.13</a> del estándar.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Utilice el script <span class="shellscript">script_var-shell.sh</span>, visto en el apartado 3.3, pero modifíquelo eliminando
            las líneas con la palabra "firefox",&nbsp; para evitar que moleste en las siguientes pruebas. Ejecute los
            siguientes comandos observando el valor de la variable especial <span class="shellscript">@</span>:</p>
            <p>
              <span class="shellscript">./script_var-shell.sh s*_for?.sh</span>
            </p>
            <p>
              <span class="shellscript">./script_var-shell.sh s*_for*.sh</span>
            </p>
            <p>
              <span class="shellscript">./script_var-shell.sh s*_exp*.sh</span>
            </p>
            <p>
              <span class="shellscript">./script_var-shell.sh s*_exp*[12].sh</span>
            </p>
            <p>
              <span class="shellscript">./script_var-shell.sh s*_e*.sh</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <h2>
        <a id="_Toc444081212" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081212">3.5 Comandos del shell</a>
      </h2>
      <p>Un comando puede ser clasificado en las siguientes tipos de comandos (de menor a mayor nivel):</p>
      <ol type="a">
        <li>
          <span>Comandos simples</span>
        </li>
        <li>
          <span>Tuberías</span>
        </li>
        <li>
          <span>Listas AND-OR</span>
        </li>
        <li>
          <span>Listas</span>
        </li>
        <li>
          <span>Listas compuestas</span>
        </li>
        <li>
          <span>Comandos compuestos (o estructuras de control)</span>
        </li>
        <li>
          <span>Definiciones de función</span>
        </li>
      </ol>
      <p>Cada uno de estos tipos se forma mediante la composición de elementos de los tipos inferior. Pero
      también se permite anidar distintos tipos de comandos (no todas las combinaciones son posibles como se verá más adelante),
      por lo que podríamos encontrarnos: tuberías de comandos compuestos, comandos compuestos formados por otros comandos
      compuestos, etc.</p>
      <p>En general, el valor devuelto por un comando compuesto (tipo b y superiores) será el valor devuelto por
      el último comando simple ejecutado.</p>
      <p>A continuación describiremos cada uno de los tipos. Puede ver más detalles en el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09">2.9</a> del
      estándar.</p>
      <h3>
        <a id="_Toc444081213" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081213">3.5.1 Comandos simples</a>
      </h3>
      <p>Un comando simple está formado por (todos los elementos son opcionales) una secuencia de asignación de
      variables y redirecciones (en cualquier orden) seguida de palabras (elemento ejecutable y sus argumentos) y redirecciones. A
      continuación se muestra la estructura genérica de un comando simple (los corchetes <span class="shellscript"><b>[ ]</b></span> indican qué elementos son opcionales, que es la notación usada en el resto de este documento):</p>
      <p><span class="shellscript"><b>[</b>VAR=v<b>]</b> <b>[</b>redir<b>] [</b>ejecutable argumentos<b>] [</b>redir<b>]</b></span></p>
      <p>Pudiendo ser el <span class="shellscript">ejecutable</span> programas "ejecutables" (comandos internos y
      ejecutables externos) e "interpretables" (funciones).</p>
      <p>Es decir, en un mismo comando simple se puede hacer simultáneamente la asignación de variables y la
      ejecución de un programa. Cuando un comando simple no incluye un programa a ejecutar, la asignación de variables afecta a
      todo el shell, de lo contrario la asignación sólo afecta al programa que se va a ejecutar.</p>
      <p>Si en un mismo comando simple hubiera que hacer expansiones en las palabras y en la asignación de
      variables, primero se hace las expansiones de las palabras.</p>
      <p>Ejemplos de comandos simples:</p>
      <p>
        <span class="shellscript">VAR=x</span>
      </p>
      <p>El anterior comando asigna el valor <span class="shellscript">x</span> a la variable <span class="shellscript">VAR</span> y afecta a todo el proceso shell actual.</p>
      <p>
        <span class="shellscript">VAR=x programa</span>
      </p>
      <p>Asigna el valor <span class="shellscript">x</span> a la variable <span class="shellscript">VAR</span> y afecta solo al programa.</p>
      <p>
        <span class="shellscript">VAR=y OTRA=z</span>
      </p>
      <p>
        <span class="shellscript">VAR=x programa $VAR</span>
      </p>
      <p>
        <span class="shellscript">echo $VAR</span>
      </p>	  
      <p>Se asigna el valor <span class="shellscript">y</span> a la variable <span class="shellscript">VAR</span> y el valor <span class="shellscript">z</span> a la variable <span class="shellscript">OTRA</span>, que
      afectan a todo el shell. A continuación, asigna el valor <span class="shellscript">x</span> a la variable <span class="shellscript">VAR</span> y afecta sólo al programa, al cual se le pasa
      como primer argumento <span class="shellscript">y</span>. A continuación se imprime <span class="shellscript">y</span> por pantalla.</p>
      <p>
        <span class="shellscript">VAR=x &gt; fichero programa</span>
      </p>
      <p>
        <span class="shellscript">VAR=x programa &gt; fichero&nbsp; #equivalente</span>
      </p>	  
      <p>Ambas líneas, asignan el valor <span class="shellscript">x</span> a la variable <span class="shellscript">VAR</span> que afecta solo al programa. Se ejecuta
      el programa y la salida estándar se redirige al archivo <span class="shellscript">fichero</span>. La redirección se realiza independientemente de
      que aparezca antes o después del programa. Si hubiera varias redirecciones se realizan en el orden de aparición en la línea,
      de izquierda a derecha.</p>
      <h3>
        <a id="_Toc444081214" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081214">3.5.2 Tuberías</a>
      </h3>
      <p>Una tubería es una secuencia de uno o más comandos (simples o compuestos, pero no ningún tipo de lista)
      separados por el operador <span class="shellscript">|</span>. La salida estándar de un comando se conecta a la entrada estándar del siguiente
      comando (cada comando se ejecuta en otro subshell simultáneamente). Esta conexión se hace previamente a cualquier
      redirección. El formato es:</p>
      <p><span class="shellscript"><b>[</b> ! <b>]</b> comando1 <b>[</b> | comando2 … <b>]</b></span></p>
      <p>Opcionalmente, se puede añadir delante el carácter <span class="shellscript">!</span> que hace la negación lógica del valor
      devuelto por el último comando, de tal manera que el valor devuelto por la tubería sería 1 si el último comando devuelve 0, o
      0 en caso contrario.</p>
      <h3>
        <a id="_Toc444081215" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081215">3.5.3 Listas AND-OR</a>
      </h3>
      <p>Una lista AND es una secuencia de tuberías (tenga en cuenta que una tubería puede ser sólo un comando
      simple) separadas por el operador <span class="shellscript">&amp;&amp;</span>. El formato es:</p>
      <p>
        <span class="shellscript">tuberia1 <b>[</b> &amp;&amp; tuberia2 …  <b>]</b></span>
      </p>
      <p>Se van ejecutando las tuberías de izquierda a derecha hasta que una de ellas devuelva un valor distinto
      de cero. No se realiza ninguna expansión en una tubería hasta que el shell no determine que tiene que ejecutar dicha tubería
      (dependerá del resultado de la tubería anterior).</p>
      <p>Una lista OR es una secuencia de tuberías separadas por el operador <span class="shellscript">||</span>. El formato es:</p>
      <p>
        <span class="shellscript">tuberia1 <b>[</b> || tuberia2 … <b>]</b></span>
      </p>
      <p>Se van ejecutando las tuberías de izquierda a derecha hasta que una de ellas devuelva un valor cero. No
      se realiza ninguna expansión en una tubería hasta que el shell no determine que tiene que ejecutar dicha tubería.</p>
      <p>Una lista AND-OR es el resultado de combinar listas AND y/o OR en una misma línea. Los operadores
      <span class="shellscript">&amp;&amp;</span> y <span class="shellscript">||</span> se evalúan con la misma prioridad de izquierda a derecha. Ejemplo:</p>
      <p>
        <span class="shellscript">tuberia1 || tuberia2 &amp;&amp; tuberia3</span>
      </p>
      <h3>
        <a id="_Toc444081216" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081216">3.5.4 Listas</a>
      </h3>
      <p>Las listas son secuencias de una o más listas AND-OR separadas por los operadores <span class="shellscript">;</span> o
      <span class="shellscript">&amp;</span>. Los operadores <span class="shellscript">;</span> y
      <span class="shellscript">&amp;</span> no pueden aparecer seguidos (por ejemplo, daría error
      <span class="shellscript">prog1 &amp; ; prog2</span>)</p>
      <p>Según el operador las listas pueden ser secuenciales, asíncronas o mixtas (combinación de ambas).</p>
      <h4>
        <a id="_Toc444081217" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081217">3.5.4.1 Listas secuenciales</a>
      </h4>
      <p>Se utiliza como separador el operador <span class="shellscript">;</span>. Se van ejecutando los distintos comandos
      secuencialmente (no se ejecuta un comando hasta que haya terminado el anterior). Cada lista AND-OR debe estar terminada por
      el operador <span class="shellscript">;</span> a excepción de la última donde es opcional. El formato es:</p>
      <p>
        <span class="shellscript">listaAND-OR1 <b>[</b> ; listaAND-OR2 … <b>] [</b> ; <b>]</b></span>
      </p>
      <h4>
        <a id="_Toc444081218" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081218">3.5.4.2 Listas asíncronas</a>
      </h4>
      <p>Se utiliza como separador el operador <span class="shellscript">&amp;</span>. Se van ejecutando los distintos comandos sin
      esperar a que el comando anterior termine (ejecución en segundo plano). El formato es:</p>
      <p>
        <span class="shellscript">listaAND-OR1 &amp; <b>[</b> listaAND-OR2 &amp; <b>]</b></span>
      </p>
      <p>En este caso, a menos que se haga una redirección explícita de la entrada estándar, si un programa en
      segundo plano lee de la entrada estándar recibirá un error de fin de fichero (EOF).</p>
      <h4>
        <a id="_Toc444081219" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081219">3.5.4.3 Listas mixtas</a>
      </h4>
      <p>Son combinaciones de listas secuenciales y asíncronas. Por ejemplo:</p>
      <p>
        <span class="shellscript">#asíncrona y secuencial
lANDOR1 &amp; lANDOR2 <b>[</b> ; <b>]</b></span>
      </p>
      <p>
        <span class="shellscript">#secuencial y asíncrona
lANDOR1 ; lANDOR2 &amp;</span>
      </p>
      <p>
        <span class="shellscript">#asíncrona y secuencial
lANDOR1 &amp; lANDOR2 &amp; lANDOR3 ; lANDOR4</span>
      </p>
      <p>
        <span class="shellscript">#secuencial, asíncrona, secuencial
lANDOR1 ; lANDOR2 &amp; lANDOR3</span>
      </p>
      <h3>
        <a id="_Toc444081220" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081220">3.5.5 Listas compuestas</a>
      </h3>
      <p>No es más que una secuencia de listas (apartado 3.5.4), separadas por el carácter de nueva línea
      (intros), terminada por el operador <span class="shellscript">;</span>, el operador <span class="shellscript">&amp;</span>, el carácter de nueva línea (intro) o un
      comando compuesto. La utilidad de este tipo de listas se verá sobre todo cuando se expliquen los comandos compuestos.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <p>Mire el contenido del script <span class="shellscript">script_operadores.sh</span>, que deberá contener lo
            siguiente:</p>
            <table class="tablaNormal">
              <thead>
                <tr>
                  <td>
                    <p class="nombreFichero">
                      <b>
                        <span class="shellscript">script_operadores.sh</span>
                      </b>
                    </p>
                  </td>
                </tr>
              </thead>
              <tbody><tr>
                <td class="contenidoFichero">
                  <pre class="shellscript">#!/bin/sh
head -1 /etc/passwd &amp;&amp; echo "Sin error1A" || echo "Con error1B"
head -1 /nofile &amp;&amp; echo "Sin error2A" || echo "Con error2B"
echo "Comando dividido \
en dos líneas"
echo "Sin escapado: $$"
echo "Con escapado: \$\$"
echo "N º de proceso del shell bash:" `pidof bash`</pre>
                </td>
              </tr>
            </tbody></table>
            <p>Compruebe que dispone del permiso de ejecución. Invóquelo y analice su funcionamiento.</p>
            <p>Desde la línea de comandos, cree listas y tuberías de todos los tipos vistos usando combinaciones
            de los comandos <span class="shellscript">ls</span>, <span class="shellscript">echo</span>, <span class="shellscript">cat</span> y <span class="shellscript">ps</span>.</p>
          </td>
        </tr>
      </tbody></table>
      <h3>
        <a id="_Toc444081221" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081221">3.5.6 Comandos compuestos o estructuras de control</a>
      </h3>
      <p>Los comandos compuestos son lo que en otros lenguajes de programación se conocen como estructuras de
      control. Cada uno de estos comandos compuestos (o estructuras de control) están delimitados por una palabra reservada u
      operador de control al principio y otro al final (terminador). Si se hace una redirección a continuación del terminador, en
      la misma línea, esa redirección se aplicará a todos los comandos que se encuentre en ese comando compuesto, a menos que se
      haga otra redirección explícita en un comando en concreto.</p>
      <p>A continuación se hace un repaso por todas las estructuras de control disponibles en el estándar POSIX.
      Puede consultar el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04">2.9.4</a> del estándar para más información.</p>
      <h4>
        <a id="_Toc444081222" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081222">3.5.6.1 Secuencial. Agrupación de comandos.</a>
      </h4>
      <p>La agrupación de comandos permite mejorar la legibilidad del código, aplicar una redirección a un
      conjunto de comandos y crear un subshell entre otras cosas.</p>
      <p>Existen dos formas de agrupar comandos, con los siguientes formatos:</p>
      <ul>
        <li>
          <span class="shellscript">( lista-compuesta )</span>
          <p>Se ejecuta la lista compuesta en un subshell. Los cambios que se produzcan en este subshell no
          afectarán al shell actual. Si la lista compuesta está terminada por el carácter de nueva línea, este carácter puede
          omitirse.</p>
        </li>
        <li>
          <span class="shellscript">{ lista-compuesta }</span>
          <p>Se ejecuta la lista compuesta en el shell actual. Recuerde que las listas compuestas están
          terminadas por los operadores <span class="shellscript">;</span>, <span class="shellscript">&amp;</span> o nueva línea (el último comando debe estar separado de la
          llave de cierre por esos operadores).</p>
        </li>
      </ul>
      <p>En ambos casos, se permite añadir una redirección al final (detrás del <span class="shellscript">)</span> o <span class="shellscript">}</span>)
      que afectará a todos los comandos del grupo.</p>
      <h4>
        <a id="_Toc444081223" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081223">3.5.6.2 Condicional: if-elif-else</a>
      </h4>
      <p>Presenta la siguiente sintaxis:</p>
      <table class="tablaNormal tablaDefiniciones">
        <tbody><tr>
          <td class="shellscript">
<b><span>if</span></b> <span>lista-compuestaA1 <b>then</b></span>
  <span>&nbsp; lista-compuestaB1</span>
<b><span>elif</span></b> <span>lista-compuestaA2 <b>then</b></span>
  <span>&nbsp; lista-compuestaB2</span>
<span>...</span>
<b><span>else</span></b>
<span>&nbsp; lista-compuestaN</span>
<b><span>fi</span></b>
          </td>
        </tr>
      </tbody></table>
      <p>Las entradas <span class="shellscript">elif</span> tienen el significado de un <span class="shellscript">else</span> seguido de un nuevo <span class="shellscript">if</span>. Puede haber tantas entradas <span class="shellscript">elif</span> como se desee. Tanto las entradas <span class="shellscript">elif</span> como la entrada <span class="shellscript">else</span> son opcionales.</p>
      <p>En esta estructura, lo primero que se hace es ejecutar la 
      <span class="shellscript">lista-compuestaA1</span>, si el valor devuelto es 0 (ADVERTENCIA: 0 significa verdadero aquí),
      se ejecutaría 
      <span class="shellscript">lista-compuestaB1</span> y terminaría la estructura 
      <span class="shellscript">if</span>. Si el valor devuelto no es 0 se comprueba el siguiente <span class="shellscript">elif</span>. Si ninguna de las listas-compuestas A devuelve 0 se ejecutaría el bloque del
      <span class="shellscript">else</span>. En otras palabras, las listas compuestas B solo se ejecutan si se ha
      comprobado su respectiva lista-compuesta A y ha devuelto 0.</p>
      <p>A veces, para mejorar la legibilidad, las listas-compuestas se encierran entre llaves (agrupación de
      comandos) pero es opcional. Asimismo, <span class="shellscript">then</span> estará en una línea u otra dependiendo del operador (<span class="shellscript">&amp;</span>,
      <span class="shellscript">;</span> o nueva línea) utilizado para terminar la lista compuesta. Si desea dejar una lista-compuesta vacía (no quiere
      realizar ninguna operación en un determinado caso), puede utilizar el comando <span class="shellscript">:</span> (comando nulo).</p>
      <p>Por ejemplo, si tenemos un programa llamado <span class="shellscript">condicion</span> que devuelve 0 si algo es verdadero y
      1 si es falso, los siguientes ejemplos son equivalentes:</p>
      <table class="tablaNormal tablaDefiniciones shellscript">
        <tbody><tr>
          <td>
if condicion; then
&nbsp;{ comando1; comando2; }
fi
          </td>
          <td>
if condicion; then
&nbsp;comando1; comando2;
fi
          </td>
        </tr>
        <tr>
          <td>
if condicion
then
&nbsp;comando1;
&nbsp;comando2;
fi
          </td>
          <td>
if condicion
then
&nbsp;comando1
&nbsp;comando2
fi
          </td>
        </tr>
        <tr>
          <td colspan="2">
if condicion; then comando1; comando2; fi
          </td>
        </tr>
        <tr>
          <td colspan="2">
if condicion; then { comando1; comando2; } fi
          </td>
        </tr>
      </tbody></table>
      <p>Recuerde que si usa las llaves, debe separarlas del resto de elementos. Por ejemplo:</p>
      <p>
        <span class="shellscript">if condicion; then <b>{c</b>omando1; &nbsp;comando2;} fi</span>
      </p>
      <p>
        <span class="shellscript">if condicion; the<b>n{</b> comando1; &nbsp;comando2;} fi</span>
      </p>
      <p>
        <span class="shellscript">if condicion; then { comando1; comando<b>2 }</b> fi&nbsp;</span>
      </p>
      <p>darán error de sintaxis.</p>
      <p>Respecto a la <span class="shellscript">condición</span>; que puede usarse, basta cualquier lista compuesta que devuelva un
      valor (por ejemplo, pueden usarse los comandos internos <span class="shellscript">true</span> o <span class="shellscript">false</span>). El valor de una lista compuesta es el valor del último comando simple
      ejecutado en la lista compuesta.</p>
      <p>Un programa habitual que se utiliza como condición es el programa <span class="shellscript"><b>test</b></span>. El comando <span class="shellscript">test</span> se puede ejecutar de dos formas (ambas equivalentes):</p>
      <p>
        <span class="shellscript">test expresion</span>
      </p>
      <p>
        <span class="shellscript">[ expression ]&nbsp; #los [] deben estar separados</span>
      </p>
      <p>En la segunda forma los corchetes no son operadores ni indican que la expresión sea opcional, sino que
      realmente son el nombre del programa.</p>
      <p>Puede ver la descripción del comando <span class="shellscript">test</span> según el <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/test.html">estándar</a>.</p>
      <p>Como expresiones más habituales pueden usarse las siguientes:</p>
      <table class="tablaNormal tablaDefiniciones3">
        <thead>
          <tr>
            <td class="celdaDestacada">
              <p class="Encabezadodelatabla centrado">
                <b>
                  <span>Tipo</span>
                </b>
              </p>
            </td>
            <td class="celdaDestacada">
              <p class="Encabezadodelatabla centrado">
                <b>
                  <span>Expresión</span>
                </b>
              </p>
            </td>
            <td class="celdaDestacada">
              <p class="Encabezadodelatabla centrado">
                <b>
                  <span>Verdadera sí (devuelve 0)</span>
                </b>
              </p>
            </td>
          </tr>
        </thead>
        <tbody><tr>
          <td rowspan="6">
            <p class="Contenidodelatabla centrado">
              <span>Enteros (n1 y n2 se convierten a enteros)</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>n1 -eq n2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>n1 = n2</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>n1 -ne n2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>n1 ≠ n1</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>n1 -gt n2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>n1 &gt; n2</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>n1 –ge n2</span></p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>n1 ≥ n2</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>n1 -lt n2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>n1 &lt; n2</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>n1 -le n2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>n1 ≤ n2</span>
            </p>
          </td>
        </tr>
        <tr>
          <td rowspan="4">
            <p class="Contenidodelatabla centrado">
              <span>Cadenas</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla shellscript">
"$VAR" = "cad"
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$VAR vale "cad". 
              <b>Es conveniente, pero no necesario, poner la variable entre comillas por si tuviera espacios o estuviese vacía,
              para que al expandirse no dé error de sintaxis.</b></span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
"$VAR" != "cad"
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$VAR vale algo distinto de "cad".</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-z "$VAR"</span>
            </p>
            <p class="Contenidodelatabla shellscript">
"$VAR"
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$VAR está vacía. Equivale a <span class="shellscript">"$VAR" = ""</span></span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-n "$VAR"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$VAR no está vacía. Equivale a <span class="shellscript">"$VAR" != ""</span> o <span class="shellscript">! -z</span></span>
            </p>
          </td>
        </tr>
        <tr>
          <td rowspan="11">
            <p class="Contenidodelatabla centrado">
              <span>Ficheros</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-e "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe. Si se indica un enlace simbólico, será cierta sólo si existe el enlace simbólico y el fichero apuntado. Es conveniente que esté entre comillas por el mismo motivo anterior.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-f "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y es regular. Si se indica un enlace simbólico, el tipo es el del fichero apuntado.</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-h "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y es un enlace simbólico</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-d "$DIR"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$DIR existe y es un fichero de tipo directorio</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-p "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y es un fichero especial tubería (pipe)</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-b "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y es un fichero especial de bloques</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-c "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y es un fichero especial de caracteres</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-r "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y puede leerse</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-w "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y puede modificarse</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-x "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y puede ejecutarse</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript">
<span>-s "$FILE"</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>$FILE existe y su tamaño es mayor de cero bytes</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <p>Cualquiera de las condiciones anteriores puede ser precedida por el operador negación <span class="shellscript">!</span>, en
      cuyo caso la condición será cierta si no se satisface la comparación indicada. Por ejemplo, <span class="shellscript">! -d $DIR</span> se cumplirá
      si <span class="shellscript">$DIR</span> NO es un directorio.</p>
      <p>Asimismo, se permite crear condiciones múltiples mediante los operadores:</p>
      <table class="tablaNormal tablaDefiniciones">
        <tbody><tr>
          <td>
            <p class="Contenidodelatabla shellscript centrado">
<span>condicion1&nbsp; -a condicion2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>AND: Verdadero si ambas condiciones son verdaderas</span>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p class="Contenidodelatabla shellscript centrado">
<span>condicion1&nbsp; -o condicion2</span>
            </p>
          </td>
          <td>
            <p class="Contenidodelatabla">
              <span>OR: Verdadero si se cumple alguna de las dos condiciones</span>
            </p>
          </td>
        </tr>
      </tbody></table>
      <p>Recuerde las restricciones de sintaxis del shell en lo que respecta a los espacios, especialmente
      importantes en la escritura de las condiciones. Por ejemplo, la siguiente entrada dará error de sintaxis (el espacio tras
      <span class="shellscript">;</span> sí puede omitirse):</p>
      <p>
        <span class="shellscript">i<b>f[</b> condicion ]; then</span>
      </p>
      <p>Y la siguiente dará error porque buscaría el comando <span class="shellscript">[comando]</span> (incluyendo los corchetes como parte del nombre del comando), que en
      general no encontrará (mostrando un mensaje de orden no encontrada).</p>
      <p>
        <span class="shellscript">if <b>[c</b>omand<b>o]</b>; then</span>
      </p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>El comando test se puede ejecutar sin necesidad de utilizarlo en una estructura de control. Escriba la siguiente
              instruccion y analice su comportamiento (pruebe asignando también 1 a la variable V y una cadena de texto):
              <p>
                <span class="shellscript">V=0; [ $V -eq 0 ] &amp;&amp; { echo ES; echo 0; } || echo ES 1</span>
              </p></li>
              <li>El siguiente comando imprime por pantalla si el usuario actual es root. Ejecútelo como root y como un usuario
              normal:
              <p>
                <span class="shellscript">if [ "`id -u`" -eq 0 ]; then echo ROOT; fi</span>
              </p></li>
              <li>Mire el contenido del siguiente script en su sistema y compruebe que tiene el permiso de ejecución:
              <table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_if.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

FILE=/tmp/archivo
if [ -r $FILE -a ! -w $FILE ]; then
&nbsp;&nbsp; echo Fichero $FILE existe y no es modificable
else
&nbsp;&nbsp; echo Fichero no encontrado o es modificable
fi

VAR1=1; VAR2=1
if [ $(($VAR1)) -ne $(($VAR2)) ]; then
&nbsp;&nbsp; echo Distintos
elif ls /; then
&nbsp;&nbsp; :
fi</pre>
                  </td>
                </tr>
              </tbody></table></li>
              <li>Ejecute los comandos siguientes y analice el resultado:
              <p>
                <span class="shellscript">rm –f /tmp/archivo</span>
              </p>
              <p>
                <span class="shellscript">./script_if.sh</span>
              </p></li>
              <li>Ejecute ahora los comandos siguientes y vuelva a analizar el resultado:
              <p>
                <span class="shellscript">touch /tmp/archivo</span>
              </p>
              <p>
                <span class="shellscript">chmod –w /tmp/archivo</span>
              </p>
              <p>
                <span class="shellscript">./script_if.sh</span>
              </p></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <h4>
      <a id="_Toc444081224" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081224">
      <span>3.5.6.3</span> Condicional</a> 
      <span>: case</span></h4>
      <p>Presenta la siguiente sintaxis:</p>
      <table class="tablaNormal tablaDefiniciones shellscript">
        <tbody><tr>
          <td>
<b>case</b> cadena_texto <b>in</b>
&nbsp; patron1) lista-compuesta1;;
&nbsp; patron2) lista-compuesta2;;
&nbsp; ...
&nbsp; * ) lista-defecto <b>[</b>;;<b>]</b> #coincide con todo
<b>esac</b>
          </td>
        </tr>
      </tbody></table>
      <p class="Predeterminado">&nbsp;</p>
      <p>
      <span class="shellscript">cadena_texto</span> debe aparecer obligatoriamente en la misma línea que la palabra reservada 
      <span class="shellscript">case</span> (la palabra reservada 
      <span class="shellscript">in</span> puede estar en la siguiente línea). En esta estructura, primero se expande 
      <span class="shellscript">cadena_texto</span> (si es necesario) y busca el primer patrón que encaje con dicho valor.
      Cuando lo encuentre, ejecuta la lista-compuesta correspondiente y finaliza la estructura. Los <span class="shellscript">patronN</span> se interpretan como cadenas de caracteres y si es necesario se expanden
      (por ejemplo, pueden contener variables). Admite los mismos caracteres que los usados para la expansión de ruta
      (<span class="shellscript">*</span>, <span class="shellscript">?</span> y <span class="shellscript">[]</span>). Asimismo, pueden usarse patrones múltiples mediante el operador
      <span class="shellscript">|</span> y opcionalmente pueden comenzar con el paréntesis:</p>
      <p>
        <span class="shellscript">patronA&nbsp; | patronB)</span>
      </p>
      <p>
        <span class="shellscript">(patronA&nbsp; | patronB)</span>
      </p>
      <p>
        <span class="shellscript">(patronC)</span>
      </p>
      <p>El doble punto y coma <span class="shellscript">;;</span> permite determinar el final de los elementos a interpretar cuando
      se cumpla su patrón asociado. Por ese motivo, el <span class="shellscript">;;</span> del último patrón puede omitirse. Es posible añadir espacios
      entre los patrones y los paréntesis abiertos <span class="shellscript">)</span> que marcan el final del patrón. 
      <span>Conforme a esto, serían sintaxis válidas alternativas las siguientes:</span></p>
      <table class="tablaNormal tablaDefiniciones shellscript">
        <tbody><tr>
          <td>
case cadena_texto in
&nbsp; patron1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd2;;
esac
          </td>
          <td>
case cadena_texto in
&nbsp; patron1 )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd2
esac
          </td>
        </tr>
        <tr>
          <td colspan="2">
case cadena_texto in patron1) cmd1; cmd2;; esac
          </td>
        </tr>
        <tr>
         <td colspan="2">
case cadena_texto in (patron1) cmd1; cmd2; esac
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>Mire el contenido del siguiente script en su sistema y compruebe que tiene el permiso de ejecución:
              
			  
<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_case.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

case $1 in
&nbsp;&nbsp;  archivo | file)
&nbsp;&nbsp;&nbsp;&nbsp;    echo Archivo ;;
&nbsp;&nbsp;  *.c)
&nbsp;&nbsp;&nbsp;&nbsp;    echo Fichero C ;;
&nbsp;&nbsp;  *)
&nbsp;&nbsp;&nbsp;&nbsp;    echo Error
&nbsp;&nbsp;&nbsp;&nbsp;    echo Pruebe otro ;;
esac</pre>
                  </td>
                </tr>
              </tbody></table>			  

              </li><li>Ejecute los comandos siguientes y analice el resultado:
              <p>
                <span class="shellscript">./script_case.sh archivo</span>
              </p>
              <p>
                <span class="shellscript">./script_case.sh file</span>
              </p>
              <p>
                <span class="shellscript">./script_case.sh file.c</span>
              </p>
              <p>
                <span class="shellscript">./script_case.sh file.c++</span>
              </p></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>
        <span>&nbsp;</span>
      </p>
      <h4>3.5.6.4 
      <span>&nbsp;</span> 
	  <span class="Ttulo4Car">
      <a id="_Toc444081225" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081225">Bucles incondicionales: for</a></span></h4>
 
      <p>&nbsp;Presenta la siguiente sintaxis:</p>
           <table class="tablaNormal tablaDefiniciones shellscript">
        <tbody><tr>
          <td>
<b>for</b> VAR <b>in</b> lista_valores; <b>do</b>
&nbsp; lista-compuesta
<b>done</b>
          </td>
          
        </tr>
      </tbody></table>
     
      <p>El nombre de la variable 
      <span class="shellscript">VAR</span> debe aparecer obligatoriamente junto con la palabra reservada 
      <span class="shellscript">for</span> en la misma línea. 
      <span class="shellscript">lista_valores</span> debe estar obligatoriamente en la misma línea que la palabra reservada 
      <span class="shellscript">in</span>. El punto y coma <span class="shellscript">;</span> puede sustituirse por un salto de línea, y viceversa. 
      <span>Así, por ejemplo, serían sintaxis válidas las siguientes</span>:</p>
      <table class="tablaNormal tablaDefiniciones3 shellscript">
        <tbody><tr>
          <td colspan="2">
for VAR in lista_valores; do lista-compuesta done
          </td>
        </tr>
        <tr>
          <td>
for VAR
in lista_valores
do
&nbsp; lista-compuesta
done
          </td>
          <td>
for VAR in lista_valores
do
&nbsp; lista-compuesta
done
          </td>
        </tr>
      </tbody></table>
      <p>
      <span class="shellscript">lista_valores</span> se corresponde con un conjunto de valores (tomándose cada valor como una
      cadena de caracteres que puede ser objeto de expansión y como caracteres de separación los caracteres definidos en la
      variable <span class="shellscript">IFS</span>). La estructura <span class="shellscript">for</span> define la variable <span class="shellscript">VAR</span> (si no ha sido previamente definida). Para
      cada uno de los valores del resultado de expandir <span class="shellscript">lista_valores</span>, la estructura inicializa la variable
      <span class="shellscript">VAR</span> con dicho valor y realiza una iteración (ejecutando lista-compuesta, en la cual suele ser habitual acceder al
      valor de la variable <span class="shellscript">VAR</span>).</p>
      <p>Es posible omitir <span class="shellscript">in lista_valores</span>. Si se omite equivale a haber escrito: <span class="shellscript">in "$@"</span></p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol><li>Ejecute el siguiente comando y compruebe
            como se puede utilizar una expansión de ruta dentro de un bucle for:
            <p><span class="shellscript">for i in ~/.*; do echo Fichero oculto: $i; done</span>
            </p>
            </li><li>Mire el contenido del siguiente script en
            su sistema, compruebe que tiene el permiso de ejecución, invóquelo y compruebe el contenido del fichero
            "ficherosalida" que crea:
			
<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_for1.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

for i in 1 2 3; do
&nbsp;&nbsp;  echo "Iteracion: $i"
done &gt; ficherosalida</pre>
                  </td>
                </tr>
              </tbody></table>				
			
			
			
			
<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_for2.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

for file in `ls /`; do
&nbsp;&nbsp;  echo "Fichero: $file"
done</pre>
                  </td>
                </tr>
              </tbody></table>	            
			
			
			
			
			
            <p>&nbsp;</p>
            Mire el contenido del siguiente script en su sistema, compruebe que tiene el permiso de ejecución e
              invóquelo.</li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <p>&nbsp;</p>
      <p>Suele ser habitual el uso del comando externo <span class="shellscript">seq</span> para generar una lista de valores. Si bien este comando no está recogido en el estándar POSIX, es habitual su presencia en la mayoría de los sistemas
	UNIX. El comando <span class="shellscript">seq</span> presenta la sintaxis:</p>
      <p>
        <span class="shellscript">seq &nbsp;&nbsp;valor_inicial&nbsp;&nbsp; valor_final</span>
      </p>
      <p>siendo ambos valores números enteros. La salida del comando es la secuencia de números enteros entre
      ambos valores extremos indicados.</p>
      <table class="tablaTarea">
        <tbody><tr>
          <td class="tareaTitulo">
            <p>TAREAS</p>
          </td>
          <td class="tareaContenido">
            <ol>
              <li>Ejecute el comando siguiente y observe su salida:
              <p>
                <span class="shellscript">seq 1 10</span>
              </p>
              </li>
              <li>Mire el contenido del siguiente script en su sistema, compruebe que tiene el permiso de ejecución general e
              invóquelo:
			  
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_for_seq.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

for i in `seq 1 3`; do
&nbsp;&nbsp;  echo "Iteracion: $i"
done</pre>
                  </td>
                </tr>
              </tbody></table>	  
		
              <p class="Predeterminado">&nbsp;</p>
              <p>
                <span>Compruebe cómo se obtiene el mismo resultado que se tenía al invocar el fichero
                <span class="shellscript">script_for1.sh</span>.</span>
              </p></li>
            </ol>
          </td>
        </tr>
      </tbody></table>
      <h4>
        <a id="_Toc444081226" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081226">3.5.6.5 Bucles condicionales: while y until</a>
      </h4>
      <p>Presentan la siguiente sintaxis:</p>
      <table class="tablaNormal tablaDefiniciones shellscript">
        <tbody><tr>
          <td>
<b>while</b> lista-comp-condicion <b>do</b>
&nbsp; lista-compuesta
<b>done</b>
          </td>
				</tr><tr>
          <td>
<b>until</b> lista-comp-condicion <b>do</b>
&nbsp; lista-compuesta
<b>done</b>
          </td>
          
        </tr>
      </tbody></table>
   
      <p>La <span class="shellscript">lista-comp-condicion</span> es una lista compuesta que se rige por las mismas directrices
      indicadas en la estructura <span class="shellscript">if</span>. La estructura:</p>
      <ul>
        <li><span class="shellscript">while</span> va iterando (interpreta la <span class="shellscript">lista-compuesta</span>) mientras se cumpla la condición indicada (<span class="shellscript">lista-comp-condicion</span> devuelve el valor 0)</li>
        <li><span class="shellscript">until</span> va iterando (interpreta la <span class="shellscript">lista-compuesta</span>) mientras NO se cumpla la condición indicada (<span class="shellscript">lista-comp-condicion</span> devuelve un valor distinto de 0).
		</li>
	</ul>
	<p>Así, por ejemplo, serían válidas y equivalentes las sintaxis siguientes, si la condición del <span class="shellscript">until</span> es la condición del <span class="shellscript">while</span> negada:</p>
	<table class="tablaNormal tablaDefiniciones3 shellscript">
	  <tbody><tr>
		<td>
while lista-comp-condW
do
&nbsp;&nbsp; cmd1
&nbsp;&nbsp; cmd2
done
		</td>
		<td>
until lista-comp-condU
do
&nbsp;&nbsp; cmd1
&nbsp;&nbsp; cmd2
done
		</td>
	  </tr>
	  <tr>
		<td colspan="2">
while lista-comp-condW ; do cmd1; cmd2; done
		</td>
	  </tr>
	  <tr>
		<td colspan="2">
while lista-comp-condW ; do { cmd1; cmd2; } done
		</td>
	  </tr>
	</tbody></table>
	<p class="Predeterminado">&nbsp;</p>
	<table class="tablaTarea">
	  <tbody><tr>
		<td class="tareaTitulo">
		  <p>TAREAS</p>
		</td>
		<td class="tareaContenido">
		  <ol>
			<li>Mire el contenido del siguiente script en su sistema, compruebe que tiene el permiso de ejecución e invóquelo:
			
			
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_while.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

CONTADOR=0
while [ $CONTADOR – lt 3 ]; do
&nbsp;&nbsp;  echo "Contador: $CONTADOR "
&nbsp;&nbsp;  CONTADOR=$(($CONTADOR+1))
done</pre>
                  </td>
                </tr>
              </tbody></table>	
		
			<p class="Lista-Tareas" style="text-indent:0cm">&nbsp;</p></li>
			<li>Mire el contenido del siguiente script en su sistema, compruebe que tiene el permiso de ejecución e invóquelo:
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_until.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

CONTADOR=0
until [ $CONTADOR – ge 3]]; do
&nbsp;&nbsp;  echo El contador es $CONTADOR
&nbsp;&nbsp;  CONTADOR=$(($CONTADOR+1))
done</pre>
                  </td>
                </tr>
              </tbody></table>				  

			<p>Podrá 
			<span>comprobar</span> cómo ambos scripts devuelven la misma salida.</p></li>
		  </ol>
		</td>
	  </tr>
	</tbody></table>
	<h4>
	  <a id="_Toc444081227" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081227">3.5.6.6 Ruptura de sentencias de control</a>
	</h4>
	<p>Igual que en otros lenguajes de programación, como en el lenguaje C, es posible romper el
	funcionamiento normal de las estructuras repetitivas ( 
	<span class="shellscript">for</span>, 
	<span class="shellscript">while</span> y 
	<span class="shellscript">until</span>). Sin embargo, hacerlo supone hacer código no estructurado. Por coherencia con
	lo visto en otras asignaturas, no se aconseja su uso.</p>
	<p>En shell script esto se realiza con dos comandos internos: <span class="shellscript">continue</span> y <span class="shellscript">break</span></p>
	<p>Ambos son comandos internos de la shell con la siguiente sintaxis y funcionalidad:</p>
	<ol type="a">
	<li><span class="shellscript">continue</span>: utilizado en estructuras de control repetitivas para detener la
	iteración actual y continuar con la siguiente. Su sintaxis es:
	<p>
	  <span class="shellscript">continue&nbsp; <b>[</b>n<b>]</b></span>
	</p>
	<p>El parámetro opcional <span class="shellscript">n</span> es un número entero positivo que permite especificar la estructura
	de control en la que se desea detener la iteración. Si se tienen varias estructuras de control anidadas, la estructura actual en la que se encuentra el <span class="shellscript">continue</span> corresponde a la estructura <span class="shellscript">1</span>; la estructura superior que
	engloba a ésta sería la estructura <span class="shellscript">2</span>, y así sucesivamente. Así, el valor de <span class="shellscript">n</span> referencia a la
	estructura de control en la que deseamos detener la iteración actual y continuar con la siguiente (por omisión,
	"n=1").</p>
	</li>
	<li><span class="shellscript">break</span>: utilizado en estructuras de control repetitivas para detener todas las
	iteraciones restantes de la estructura de control actual. 
	<span>Su sintaxis es:</span>
	<p>
	<span class="shellscript">break&nbsp; <b>[</b>n<b>]</b></span></p>
	<p>El parámetro opcional <span class="shellscript">n</span> es un número entero positivo que permite indicar si se desean
	cancelar varias estructuras de control anidadas (por omisión, "n=1", que referencia a la estructura actual en la
	que se encuentra el  <span class="shellscript">break</span>).</p>
	</li>
	</ol>
	<h3>
	  <a id="_Toc444081228" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081228">3.5.7 Funciones </a>
	</h3>
	<p>Presentan la siguiente sintaxis:</p>
	<table class="tablaNormal tablaDefiniciones3">
	  <tbody><tr>
		<td class="celdaDestacada">
		  <p class="Contenidodelatabla centrado">
			<b>
			  <span>Definición</span>
			</b>
		  </p>
		</td>
		<td>
		  <p class="Contenidodelatabla shellscript">
<span>fnombre() comando-compuesto [redir]</span>
		  </p>
		</td>
	  </tr>
	  <tr>
		<td class="celdaDestacada">
		  <p class="Contenidodelatabla centrado">
			<b>
			  <span>Invocación</span>
			</b>
		  </p>
		</td>
		<td>
		  <p class="Contenidodelatabla shellscript">
<span>fnombre&nbsp; [arg1&nbsp; arg2 … ]</span>
		</p>
		</td>
	  </tr>
	</tbody></table>
	
	<p>El paréntesis siempre debe estar vacío (sólo indica que se está definiendo una función). Pueden
	insertarse espacios antes, entre y después del paréntesis. El comando compuesto puede ser cualquier de los que se han visto
	(agrupación de comandos, estructuras condicionales, estructuras repetitivas). Opcionalmente pueden aplicarse redirecciones
	a la función (afecta a los comandos que contiene, salvo que contengan una redirección explícita). A continuación se
	muestran ejemplos básicos de definición de funciones:</p>
	<table class="tablaNormal tablaDefiniciones shellscript">
	  <tbody><tr>
		<td>
fnombre(){
&nbsp; comando1
&nbsp; comando2
}
		</td>
		<td>
fnombre(){
&nbsp; comando1;
&nbsp; comando2;
}
		</td>
		
	  </tr>
	  
	  <tr>
		
		<td colspan="2">
fnombre() { comando1; comando2; }
		</td>
		
	  </tr>
	</tbody></table>

	<p>En lo que se refiere al nombrado de las funciones, se aplican los mismos criterios antes expuestos
	para el nombrado de las variables.</p>
	<p>El estándar permite que dentro de una función se invoque a otra. Los argumentos pasados a la función
	en su invocación son accesibles desde el cuerpo de la función mediante los parámetros posicionales  <span class="shellscript">$1</span>,
	 <span class="shellscript">$2</span>,...,  <span class="shellscript">$9</span>,  <span class="shellscript">${10}</span>,... Por tanto, dentro de la función, los parámetros posicionales no
	corresponden a los argumentos usados en la invocación del script.</p>
	<p>Al igual que las variables, las funciones son:</p>
	<ul>
	<li>Locales: sólo existen en el proceso shell en que son definidas.</li>
	<li>Sólo son accesibles desde el momento de su definición hacia abajo del script, esto es, siempre deben definirse primero
	e invocarse después (no puede invocarse a una función que es definida más adelante).</li>
	<li>Dentro de la función son visibles todas las variables y funciones definidas antes de su invocación. Y las variables
	definidas dentro de la función son visibles fuera tras la invocación de la función.
	</li></ul>
	<p>Dentro del cuerpo de la función suele ser habitual el uso del comando <span class="shellscript">return</span>, el cual provoca la salida inmediata de la función con el valor de
	retorno (número) indicado:</p>
	<p>
	  <span class="shellscript">return&nbsp; [n]</span>
	</p>
	<p>Si no se indica ningún valor de retorno, la función devuelve el valor del último comando ejecutado.
	Como siempre, el valor devuelto por la función puede obtenerse con la variable  <span class="shellscript">$?</span>. <span class="shellscript">return</span> también puede utilizarse para terminar un script invocado implícitamente
	con <span class="shellscript">.</span>.</p>
	
	<table class="tablaTarea">
	  <tbody><tr>
		<td class="tareaTitulo">
		  <p>TAREAS</p>
		</td>
		<td class="tareaContenido">
		  <p>Mire el contenido del siguiente script en su sistema, compruebe que tiene el permiso de
		  ejecución, &nbsp;invóquelo con 2 números enteros como argumentos y analice su funcionamiento :</p>
		  
		  
		  
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_funcion.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh

suma () {
&nbsp;&nbsp;  C=$(($1+$2))
&nbsp;&nbsp;  echo "Suma: $C"
&nbsp;&nbsp;  return $C
&nbsp;&nbsp;  echo "No llega"
}

suma 1 2
suma $1 $2 #suma los 2 primeros argumentos
echo "Valor devuelto: " $? </pre>
                  </td>
                </tr>
              </tbody></table>			  

		</td>
	  </tr>
	</tbody></table>
	<h2>
	  <a id="_Toc444081229" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081229">
	  <span>3.6</span> Uso de comandos y aplicaciones</a>
	</h2>
	<p>Con objeto de alcanzar una mayor homogeneización entre los sistemas, el estándar POSIX recoge una
	lista de comandos que deben ser implementados en cualquier sistema, clasificándolos según sean ordenes internas del shell
	(built-in) o aplicaciones externas.</p>
	<h3>
	  <a id="_Toc444081230" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081230">3.6.1 Comandos internos</a>
	</h3>
	<p>Los comandos internos corresponden a órdenes interpretadas por el propio shell (luego no existe ningún
	fichero ejecutable asociado al comando). Se distinguen dos tipos de comandos internos:</p>
	<ul>
	<li>
	  <span>Especiales: un error producido al ejecutar este comando da lugar a que el shell termine. Por consiguiente, el
	  script termina con un error y un valor de retorno mayor de cero (vea el apartado <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_08_02">2.8.2</a> del estándar para saber el valor
	  de retorno).</span>
	</li>
	<li>
	  <span>Regulares: el shell no tiene que terminar cuando se produce un error en estos comandos.</span>
	</li>
	</ul>
	  <p>En la siguiente tabla se recogen los comandos especiales definidos en el estándar.</p>
	  
	  <table class="tablaNormal tablaDefiniciones">
		<thead>
		  <tr>
			<td class="celdaDestacada">
			  <p class="Encabezadodelatabla centrado">
				<b>
				  <span>Comando interno especial</span>
				</b>
			  </p>
			</td>
			<td class="celdaDestacada">
			  <p class="Encabezadodelatabla centrado">
				<b>
				  <span>Descripción</span>
				</b>
			  </p>
			</td>
		  </tr>
		</thead>
		<tbody><tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">break</span>,<span class="shellscript">continue</span>, <span class="shellscript">export</span>, <span class="shellscript">return</span>, <span class="shellscript">unset</span>, <span class="shellscript">.</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Se han descrito anteriormente.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">:</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Comando nulo. Se suele utilizar en estructuras de control que requieren un comando para ser sintácticamente
			  correctas, pero no se quiere hacer nada.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">eval</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Permite crear comandos a partir de sus argumentos (ver más adelante)</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">exec</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Ejecuta comandos (sustituyendo al shell actual) y abre, cierra y copia descriptores de fichero</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">exit</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Provoca que el shell termine (ver más adelante)</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">readonly</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Permite hacer que una variable sea de sólo lectura (no admite asignaciones)</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">set</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Establece opciones del proceso shell actual y modifica los parámetros posicionales.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">shift</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Elimina el número indicado de parámetros posicionales empezando desde el 1, desplazando el resto de
			  parámetros a posiciones inferiores.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">times</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Muestra los tiempos de procesamiento del shell y sus procesos hijos.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla centrado">
			  <span class="shellscript">trap</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Permite atrapar o ignorar señales del sistema.</span>
			</p>
		  </td>
		</tr>
	  </tbody></table>
	  <p>
	  <br>Puede obtener más información en el <a href="http://pubs.opengroup.org/onlinepubs/009695399/idx/sbi.html">estándar</a>.</p>
	  <p>Como comandos internos regulares, el estándar define los siguientes:</p>
	  
	  <table class="tablaNormal tablaDefiniciones">
		<tbody><tr>
		  <td class="celdaDestacada">
			<p class="Contenidodelatabla centrado">
			  <b>
				<span>Básicos regulares</span>
			  </b>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla centrado">
<span class="shellscript">bg</span>,
<span class="shellscript">cd</span>,
<span class="shellscript">false</span>,
<span class="shellscript">fg</span>,
<span class="shellscript">jobs</span>,
<span class="shellscript">kill</span>,
<span class="shellscript">pwd</span>,
<span class="shellscript">read</span>,
<span class="shellscript">true</span>,
<span class="shellscript">wait</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td class="celdaDestacada">
			<p class="Contenidodelatabla centrado">
			  <b>
				<span>Para Profundizar regulares</span>
			  </b>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla centrado">
<span class="shellscript">alias</span>,
<span class="shellscript">command</span>,
<span class="shellscript">fc</span>,
<span class="shellscript">getopts</span>,
<span class="shellscript">newgrp</span>,
<span class="shellscript">umask</span>,
<span class="shellscript">unalias</span>
			</p>
		  </td>
		</tr>
	  </tbody></table>

	  <p>Consulte el <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tagtcjh_5">estándar</a> para más información.</p>
	  <p>Entre dichos comandos (especiales y regulares), por su utilidad en los shell-scripts deben
	  destacarse los siguientes:</p>
	  <h4>
		<a id="_Toc444081231" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081231">3.6.1.1 Salida del proceso shell actual,  <span class="shellscript">exit</span></a>
	  </h4>
	  <p>La sintaxis de este comando es:</p>
	  <p>
	  <span class="shellscript">exit [n]</span></p>
	  <p><span class="shellscript">exit</span> provoca la eliminación inmediata del proceso correspondiente al shell que
	  está leyendo el script. El parámetro opcional es un número entero que corresponde al valor devuelto por el script. Si no
	  se indica ningún parámetro, el valor devuelto por el script será el del último comando ejecutado.</p>
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<ol>
			  <li>Abra una consola de comandos. Mediante el comando <span class="shellscript">su</span> abra una sesión con el superusuario. Al abrir la sesión con <span class="shellscript">root</span>, se ha creado un nuevo proceso en memoria correspondiente al
			  shell encargado del intérprete de comando en la sesión del <span class="shellscript">root</span>. Use el comando <span class="shellscript">ps ax</span> para localizar dicho proceso.
			  </li>
			  <li>
			  Ejecute el comando <span class="shellscript">exit</span>, volviendo al usuario normal. Esto habrá provocado la eliminación del proceso shell encargado
			  de la línea de comandos como en la que trabajaba <span class="shellscript">root</span>. Ejecute de nuevo <span class="shellscript">ps ax</span> comprobando cómo dicho proceso ha desaparecido</li>
			<li>Mire el contenido del script <span class="shellscript">script_exit.sh</span>, que deberá contener lo siguiente:
			
			
			
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_exit.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">echo Dentro del script
exit 3
echo Fuera del script</pre>
                  </td>
                </tr>
              </tbody></table>				
			<p>&nbsp;</p>
			</li>
			<li>
			Compruebe que dispone del permiso de ejecución general. Vuelva a usar el comando <span class="shellscript">su</span> para abrir una&nbsp; sesión con el superusuario. Desde dicha sesión
			ejecute el comando anterior mediante las siguientes invocaciones:
			<p>
			  <span class="shellscript">/bin/bash&nbsp;&nbsp; script_exit.sh</span>
			</p>
			<p>
			  <span class="shellscript">./script_exit.sh</span>
			</p>
	
			<p>Ambas invocaciones provocan la creación de un
			subshell (un nuevo proceso shell) encargado de leer el script. Por ello, cuando se llega al comando <span class="shellscript">exit</span> se para la interpretación del script y dicho subshell es eliminado,
			volviendo al proceso shell padre correspondiente a la línea de comandos desde la que estábamos trabajando.</p>
			<p>Ejecute el comando <span class="shellscript">echo $?</span> para comprobar cómo el script ha devuelto el código de error
			"3".</p>
			</li>
			<li>
			Ejecute los siguientes comandos:
			<ul><li>
			<span class="shellscript">script_exit.sh &amp;&amp; echo Hola</span>, comprobando que no se imprime la
			cadena <span class="shellscript">Hola</span> debido a que el script devuelve un código de error (&gt;0).
			</li>
			<li>
			<span class="shellscript">script_exit.sh || echo Hola</span>, comprobando que ahora sí se imprime.
			</li>
			<li>
			Edite el script para que el comando <span class="shellscript">exit</span> devuelva cero (<span class="shellscript">exit 0</span>), y vuelva a invocar el comando <span class="shellscript">script_exit.sh &amp;&amp; echo Hola</span>, comprobando que ahora también se
			imprime la cadena <span class="shellscript">Hola</span>.</li>
			</ul>
			</li>
			<li>
			Vuelva a invocar el script pero ahora mediante:
			<p>
			  <span class="shellscript">.&nbsp; script_exit.sh</span>
			</p>
			<p>Verá cómo la sesión del <span class="shellscript">root</span> se cierra automáticamente y vuelve a la sesión del usuario normal. Esto se debe a que en este caso no se está creando ningún nuevo
			subshell, sino que el propio shell de la línea de comandos del usuario <span class="shellscript">root</span> es el encargado de interpretar el script. Al llegar al comando
			<span class="shellscript">exit</span>, éste provoca la eliminación del proceso shell que lee el script,
			esto es, la eliminación de la sesión del usuario <span class="shellscript">root</span>.</p>
			<p>Ejecute el comando <span class="shellscript">echo $?</span> para comprobar cómo el script ha devuelto el código de error
			<span class="shellscript">0</span> (sin error) correctamente.</p>
			</li>
			<li>
			Ejecute y analice el funcionamiento de los siguientes comandos:
			<p>
			  <span class="shellscript">sh -c "exit 0" &amp;&amp; echo "Sin error1A" || echo "Con error1B"</span>
			</p>
			<p>
			  <span class="shellscript">sh -c "exit 1" &amp;&amp; echo "Sin error2A" || echo "Con error2B"</span>
			</p>
			</li>
			</ol>
		  </td>
		</tr>
	  </tbody></table>

	  <h4>
		<a id="_Toc444081232" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081232">3.6.1.2 Entrada estándar a un shell-script,  <span class="shellscript">read</span></a>
	  </h4>
	  <p>El comando  <span class="shellscript">read</span>read lee una línea de la entrada estándar (teclado) y la guarda en variables.
	  Solo funciona en shell interactivos (leyendo la entrada del teclado), de lo contrario no hace nada. En su forma más
	  básica, presenta la siguiente sintaxis:</p>
	  <p>
		<span class="shellscript">read VAR1 [VAR2 …]</span>
	  </p>
	  <p>Este comando espera a que el usuario introduzca una línea de texto incluyendo espacios (la entrada
	  termina cuando el usuario pulsa la tecla "Intro"; la pulsación "Intro" no forma parte del valor
	  asignado a la cadena). Esta línea se divide en campos (según la variable  <span class="shellscript">IFS</span>). Tras ello, el comando define las variables
	  dadas como argumentos, inicializándolas con los campos obtenidos en la división. Si hay más campos que variables, los
	  campos restantes se asignan a la última variable. Si hay más variables que campos, las variables sobrantes reciben como
	  valor la cadena vacía 
	  <span class="shellscript">""</span>.</p>
	  <p>Consulte la <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/read.html">página del estándar</a> para obtener más información.</p>
	  <p>Algunos intérpretes de comandos como <span class="shellscript">bash</span> añaden otras opciones a este comando, como la posibilidad de imprimir un
	  mensaje usando la opción <span class="shellscript">-p</span> (vea la ayuda de  <span class="shellscript">read</span> en  <span class="shellscript">bash</span> con el comando <span class="shellscript">man bash</span>).</p>
	  
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<p>Cree el script  <span class="shellscript">script_read.sh</span>; (éste, como es breve, no se le proporciona) que
			contenga lo siguiente:</p>
	
			
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_read.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">echo " Introduzca una cadena "
read CAD
echo " Cadena introducida: $CAD "</pre>
                  </td>
                </tr>
              </tbody></table>	

			
			
		
			<p>Asígnele el permiso de ejecución general, invóquelo y analice su funcionamiento.</p>
		  </td>
		</tr>
	  </tbody></table>

	  <p>El comando <span class="shellscript">read</span> también puede ser útil, por ejemplo, para detener la interpretación del
	  script hasta que el usuario pulse una tecla:</p>
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<p>Cree el script  <span class="shellscript">script_read_pause.sh</span> que contenga lo siguiente:</p>
		
			
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_read_pause.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">echo "Pulse intro para continuar..."
read CAD
echo " Continuamos... "</pre>
                  </td>
                </tr>
              </tbody></table>				

			
			<p>Asígnele el permiso de ejecución general, invóquelo y analice su funcionamiento.</p>
		  </td>
		</tr>
	  </tbody></table>

	  <p>Resulta habitual el uso de estructuras 
	  <span class="shellscript">while</span>, combinadas con <span class="shellscript">case</span> y <span class="shellscript">read</span>, para crear menús interactivos, permitiendo mantenerse dentro del
	  menú.</p>
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<ol>
			  <li>Edite el script <span class="shellscript">script_case_menu.sh</span> para que tenga el siguiente contenido:
			  
			  
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_case_menu.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh
clear
SALIR=0
OPCION=0
while [ $SALIR -eq 0 ]; do
&nbsp;&nbsp; echo "Menu:"
&nbsp;&nbsp; echo "1) Opcion 1"
&nbsp;&nbsp; echo "2) Opcion 2"
&nbsp;&nbsp; echo "3) Salir"
&nbsp;&nbsp; echo "Opcion seleccionada: "
&nbsp;&nbsp; read OPCION
&nbsp;&nbsp; case $OPCION in
&nbsp;&nbsp;&nbsp;&nbsp;   1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     echo "Opcion 1 seleccionada" ;;
&nbsp;&nbsp;&nbsp;&nbsp;   2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     echo "Opcion 2 seleccionada" ;;
&nbsp;&nbsp;&nbsp;&nbsp;   3)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     SALIR=1 ;;
&nbsp;&nbsp;&nbsp;&nbsp;   *)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   echo "Opcion erronea";;
&nbsp;&nbsp; esac
done</pre>
                  </td>
                </tr>
              </tbody></table>	
			  <p>
			  El comando <span class="shellscript">clear</span>, tampoco recogido en el estándar POSIX, también suele encontrarse habitualmente en la mayoría de los sistemas UNIX. Su funcionalidad es, simplemente, limpiar la información impresa en la consola de comandos.</p>
			  </li><li>Ejecute el comando siguiente y seleccione las opciones del menú:
			  <p>
				<span class="shellscript">script_case_menu.sh</span>
			  </p></li>
			</ol>
		  </td>
		</tr>
	  </tbody></table>
	  
	  
	  
	  <h4>
		<a id="_Toc444081233" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081233">3.6.1.3 Construcción de comandos en tiempo de ejecución:  <span class="shellscript">eval</span></a>
	  </h4>
	  <p>El comando  <span class="shellscript">eval</span> construye un comando mediante la concatenación de sus argumentos (pueden ser
	  variables, etc.) separados por espacios. Dicho comando construido es leído por el shell e interpretado. La sintaxis del
	  comando es:</p>
	  <p>
		<span class="shellscript">eval [argumentos …]</span>
	  </p>
	  <p>Un posible uso es la creación de referencias indirectas a variables (parecido a usar punteros en
	  lenguaje de programación C). En la tarea siguiente se muestra esto.</p>
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<p>Cree el script <span class="shellscript">script_eval.sh</span> que contenga lo siguiente:</p>
		
		
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_eval.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#ejemplo de referencia indirecta con eval
VAR="Texto"
REF=VAR    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#REF es una variable que vale VAR
eval OTRA='$'$REF  &nbsp;#equivale a ejecutar OTRA=$VAR
echo $OTRA &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#se ha accedido al contenido de VAR a través de REF</pre>
                  </td>
                </tr>
              </tbody></table>			

		
		
			<p>Asígnele el permiso de ejecución, invóquelo y analice su funcionamiento.</p>
		  </td>
		</tr>
	  </tbody></table>

	  <h3>
		<a id="_Toc444081234" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081234">3.6.2 Comandos externos</a>
	  </h3>
	  <p>Los comandos externos corresponden a ficheros ejecutables externos al shell. Cualquier posible
	  aplicación pertenecería a esta categoría de comandos ( <span class="shellscript">ps</span>,  <span class="shellscript">firefox</span>,  <span class="shellscript">emacs</span>,...). El estándar POSIX recoge una lista de
	  comandos externos que aconsejablemente deberían estar en un sistema UNIX, clasificándolos en obligatorios u opcionales
	  según se exija o no su implementación para satisfacer el estándar. Entre los comandos externos obligatorios, el estándar
	  define los siguientes:</p>
	  <table class="tablaNormal tablaDefiniciones">
		<tbody><tr>
		  <td class="celdaDestacada">
			<p class="Contenidodelatabla centrado">
			  <b>
				<span>Básicos</span>
			  </b>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
<span class="shellscript">cat</span>,
<span class="shellscript">chmod</span>,
<span class="shellscript">chown</span>,
<span class="shellscript">cmp</span>,
<span class="shellscript">cp</span>,
<span class="shellscript">date</span>,
<span class="shellscript">dirname</span>,
<span class="shellscript">echo</span>,
<span class="shellscript">expr</span>,
<span class="shellscript">printf</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td class="celdaDestacada">
			<p class="Contenidodelatabla centrado">
			  <b>
				<span>Para Profundizar</span>
			  </b>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
<span class="shellscript">awk</span>,
<span class="shellscript">basename</span>,
<span class="shellscript">chgrp</span>			
			</p>
		  </td>
		</tr>
	  </tbody></table>
	  <p class="Predeterminado">&nbsp;</p>
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<p>Busque información sobre el comando 
			<span class="shellscript">echo</span> y 
			<span class="shellscript">printf</span>. Ejecute los siguientes comandos y analice su funcionamiento:</p>
			<p>
			  <span class="shellscript">echo Uno</span>
			</p>
			<p>
			  <span class="shellscript">echo –n Uno; echo Dos</span>
			</p>
			<p>
			  <span class="shellscript">echo –e "Uno\nDos"</span>
			</p>
			<p>
			  <span class="shellscript">NOMBRE=Ana ; printf "Hola %s. Adios %s\n" $NOMBRE $NOMBRE</span>
			</p>
		  </td>
		</tr>
	  </tbody></table>

	  <h1>
		<a id="_Toc444081235" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081235">4 Depuración de shell-scripts</a>
	  </h1>
	  <p>Si bien la programación de shell-scripts no se puede depurar fácilmente, los shells suelen ofrecer
	  algunos mecanismos en este aspecto. En concreto, tanto "bash" como "dash" ofrecen los siguientes
	  argumentos, que pueden usarse simultáneamente:</p>
	  <table class="tablaNormal tablaDefiniciones">
		<tbody><tr>
		  <td>
			<p class="Contenidodelatabla shellscript centrado">
<span>-x</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Traza: expande cada orden simple, e imprime por
			  pantalla la orden con sus argumentos, y a continuación su salida.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla shellscript centrado">
<span>-v</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Verbose: Imprime en pantalla cada elemento completo
			  del script (estructura de control, ...) y a continuación su salida.</span>
			</p>
		  </td>
		</tr>
	  </tbody></table>
	  
	  <p>También es posible depurar sólo parte del script insertando en él los siguientes comandos (pueden
	  usarse igualmente en la propia línea de comandos):</p>
	  <table class="tablaNormal tablaDefiniciones">
		<tbody><tr>
		  <td>
			<p class="Contenidodelatabla shellscript centrado">
<span>set -x</span>
<span>set –xv</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Activa las trazas/verbose. Ubicarlo justo antes del trozo del script que se desea depurar.</span>
			</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="Contenidodelatabla shellscript centrado">
<span>set +x</span>
<span>set +xv</span>
			</p>
		  </td>
		  <td>
			<p class="Contenidodelatabla">
			  <span>Desactiva las trazas/verbose. Ubicarlo justo después del trozo del script que se desea depurar.</span>
			</p>
		  </td>
		</tr>
	  </tbody></table>
	  <p>&nbsp;</p>
	  <table class="tablaTarea">
		<tbody><tr>
		  <td class="tareaTitulo">
			<p>TAREAS</p>
		  </td>
		  <td class="tareaContenido">
			<ol>
			  <li>Mire el contenido del siguiente script en su sistema y compruebe que tiene el permiso de ejecución general:
			  
			  
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_depuracion.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh
echo Hola
if true; then
&nbsp;&nbsp;   echo hola2
&nbsp;&nbsp;   ls /
fi</pre>
                  </td>
                </tr>
              </tbody></table>			  
			  
			  </li>
			  <li>Invoque dicho script con las siguientes opciones de depuración y analice la salida:
			  <p>
				<span class="shellscript">/bin/bash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; script_depuracion.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/bash&nbsp; -x&nbsp;&nbsp; script_depuracion.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/bash&nbsp; -v&nbsp;&nbsp; script_depuracion.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/bash&nbsp; -xv&nbsp; script_depuracion.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/dash&nbsp; -x&nbsp;&nbsp; script_depuracion.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/dash&nbsp; -v&nbsp;&nbsp; script_depuracion.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/dash&nbsp; -xv&nbsp; script_depuracion.sh</span>
			  </p>
			  </li>
			  <li>Modifique el script para que tenga el siguiente contenido:
			  
			  
			<table class="tablaNormal">
                <thead>
                  <tr>
                    <td>
                      <p class="nombreFichero">
                        <b>
                          <span class="shellscript">script_depuracion2.sh</span>
                        </b>
                      </p>
                    </td>
                  </tr>
                </thead>
                <tbody><tr>
                  <td class="contenidoFichero">
                    <pre class="shellscript">#!/bin/sh
echo Hola
set -xv
if true; then
&nbsp;&nbsp;   echo hola2
&nbsp;&nbsp;   ls /
fi 
set +xv</pre>
                  </td>
                </tr>
              </tbody></table>				  
			  

					  
					  
			</li>
			<li>
			Invoque dicho script con los siguientes comandos y analice la salida:
			  <p>
				<span class="shellscript">script_depuracion2.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/dash&nbsp; script_depuracion2.sh</span>
			  </p>
			  <p>
				<span class="shellscript">/bin/bash&nbsp; script_depuracion2.sh</span>
			  </p></li>
			</ol>
		  </td>
		</tr>
	  </tbody></table>

	  

	  <h1>
		<a id="_Toc444081236" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081236">5 Propuesta de ejercicios</a>
	  </h1>
	  <p>A continuación se le propone la creación de una serie de scripts. Para ello, será necesario tanto
	  usar los conocimientos expuestos en este documento, como otros relativos a la
	  administración de Linux:</p>
	  <ol type="a">
	  <li>Los ficheros <span class="shellscript">/etc/profile</span> (leído en el arranque del sistema y común para todos los
	  usuarios), <span class="shellscript">~/.bashrc</span>, <span class="shellscript">~/.bash_profile</span> (leídos al abrir una sesión con el usuario correspondiente, no
	  es necesario que existan ambos), usados para cargar las variables de entorno, son en realidad shell-scripts. Analice el
	  contenido de dichos scripts y modifíquelos convenientemente para definir los alias:
	  <ul><li><span class="shellscript">alias red='ifconfig -a'</span>: para todos los usuarios
	  del sistema.
	  </li><li><span class="shellscript">alias casa='echo $PWD'</span>: sólo para el usuario
	  normal.</li>
	  <li><span class="shellscript">alias sockets='netstat -l'</span>: sólo para el usuario
	  <span class="shellscript">root</span>.</li>
	  </ul>
	  <p>Repita lo anterior pero utilizando funciones en vez de alias.</p>
	  </li>
	  <li>Cree los siguientes scripts:
	  <ul>
	  <li>
	  <span class="shellscript">variables.sh</span>: debe inicializar las variables <span class="shellscript">CONFIG='-a'</span>, <span class="shellscript">ARP='-n'</span> y <span class="shellscript">ROUTE</span>.
	  </li><li><span class="shellscript">funciones.sh</span>: debe definir las funciones <span class="shellscript">arranque_red()</span> (encargada de activar la tarjeta "eth0"), <span class="shellscript">parada_red()</span> (encargada de desactivar la tarjeta <span class="shellscript">eth0</span>) y <span class="shellscript">estado_red()</span> (encargada de ejecutar los comandos <span class="shellscript">ifconfig</span>, <span class="shellscript">arp</span> y <span class="shellscript">route</span> aplicándoles los parámetros pasados a la función en los argumentos 1, 2
	  y 3, respectivamente).
	  </li><li><span class="shellscript">script1.sh</span>: debe importar las variables y funciones definidas por los dos
	  scripts anteriores. Mostrará al usuario un menú en el que le pregunte si desea arrancar la red (invocando la función
	  <span class="shellscript">arranque_red()</span>), pararla (función <span class="shellscript">parada_red()</span>) o mostrar su estado (función <span class="shellscript">estado_red()</span>). Debe comprobar si alguna de las variables&nbsp; <span class="shellscript">CONFIG</span>, <span class="shellscript">ARP</span> y <span class="shellscript">ROUTE</span> es nula y, en caso de serlo, permitirle al usuario escribir
	  interactivamente (mediante la función <span class="shellscript">read</span>) los parámetros con los que invocar el comando correspondiente.
	  </li>
	  </ul>
	</li>
	<li><span class="shellscript">script_copy.sh</span>: script que copie un fichero regular en otro, ambos pasados
	  como argumentos. Si no se le pasan los argumentos, lo comprobará, y solicitará al usuario que los introduzca
	  interactivamente.</li>
	<li><span class="shellscript">script_print.sh</span>: script que imprima en pantalla el contenido de un fichero de
	  datos, o el contenido de todos los ficheros de un directorio, según se le pase como argumento un fichero regular o un
	  directorio.</li>
	<li><span class="shellscript">script_borrar.sh</span>: script que borre con confirmación todos los ficheros pasados
	  como argumentos.</li>
	<li><span class="shellscript">script_sesiones.sh</span>: script al que, pasándole el login de un usuario, devuelva
	  cuántas sesiones tiene abiertas en el sistema.</li>
	<li><span class="shellscript">script_mostrar.sh</span>: script que para cada argumento que reciba (puede recibir
	  una lista de argumentos) realice una de las siguientes operaciones:
	  <ul>
	  <li>Si es un directorio, ha de listar los ficheros que contiene.
	  </li><li>Si es un fichero regular, tiene que imprimir su contenido por pantalla.
	  </li><li>En otro caso, debe indicar que no es ni un fichero regular ni un directorio
	  (por ejemplo, un fichero de bloques o de caracteres del directorio <span class="shellscript">/dev</span>).
	  </li>
	  </ul>
	  
	  </li>
	<li><span class="shellscript">script_ejecucion.sh</span>: script que asigne el permiso de ejecución a los ficheros
	  regulares o directorios pasados como argumento (puede admitir una lista de ficheros).</li>
	<li><span class="shellscript">script_doble.sh</span>: script que pida un número por teclado y calcule su doble.
	  Comprobará que el número introducido es válido y, antes de terminar, preguntará si deseamos calcular otro doble, en cuyo
	  caso no terminará.</li>
	<li><span class="shellscript">script_tipos.sh</span>: script que devuelva el número de ficheros de cada tipo
	  (ficheros regulares o directorios) que hay en una determinada carpeta, así como sus nombres. Tendrá un único argumento
	  (opcional) que será la carpeta a explorar. Si se omite dicho argumento, se asumirá el directorio actual. Devolverá
	  <span class="shellscript">0</span> (éxito) si se ha invocado de forma correcta o <span class="shellscript">1</span> (error) en caso contrario.</li>
	<li><span class="shellscript">script_user.sh</span>: script que reciba como argumento el login de un usuario e
	  imprima por pantalla la siguiente información: login, nombre completo del usuario, directorio home, shell que utiliza,
	  número de sesiones actualmente abiertas y procesos pertenecientes a dicho usuario. 
	  <span>El script debe permitir las siguientes opciones:</span>
	  <ul>
	  <li><span class="shellscript">-p</span>: sólo muestra la información de los procesos.
	  </li><li><span class="shellscript">-u</span>: muestra toda la información excepto la referente a los procesos.
	  </li><li><span class="shellscript">--help</span>: muestra información de ayuda (uso del script).</li>
	  </ul>
	  <p>El script debe comprobar si los argumentos pasados son correctos, así como la existencia del usuario
	  indicado. Como código de error podrá devolver <span class="shellscript">0</span> (éxito), <span class="shellscript">1</span> (sintaxis de invocación errónea),
	  <span class="shellscript">2</span> (usuario no existe).</p>
	  </li>
	<li><span class="shellscript">script_menu.sh</span>: script que ofrezca al usuario un menú (con una opción para
	  salir) desde el que el usuario pueda seleccionar cual de los scripts anteriores (apartados "b)" a
	  "k)") quiere utilizar.</li>
	<li><span class="shellscript">script_puerto.sh</span>: script que reciba como argumento un número de puerto TCP
	  (PUERTO) y comprobará si el valor es un número entero positivo en el rango "[1, 1023]", de modo que:
	  <ul><li>Si es así: el script analizará si los puertos TCP "PUERTO" y
	  "PUERTO+1" del equipo local se encuentran a la escucha. Tras ello, imprimirá un mensaje indicando el estado
	  obtenido. Para ello, puede analizar la salida del comando <span class="shellscript">netstat</span>.
	  </li><li>En otro caso: imprimirá por pantalla un mensaje indicando que el valor indicado
	  no es un puerto de sistema.</li>
	  </ul>
	  </li><li><span class="shellscript">script_arp.sh</span>: script que reciba como argumento un número entero, guardándolo
	  en la variable <span class="shellscript">POS_ARP</span>. El script comprobará si el valor de la variable <span class="shellscript">POS_ARP</span> es un número
	  entero positivo, de modo que:
	  <ul><li>Si es así: el script calculará el número de entradas que actualmente tiene la
	  caché ARP del equipo, guardándolo en la variable <span class="shellscript">NENTRADAS</span>. Si el valor de <span class="shellscript">POS_ARP</span> es mayor que
	  <span class="shellscript">NENTRADAS</span>, imprimirá por pantalla un mensaje tal como: <span class="shellscript">Ninguna entrada en la posición POS_ARP</span>. En caso de que
	  <span class="shellscript">POS_ARP</span> sea menor o igual que <span class="shellscript">NENTRADAS</span>, imprimirá por pantalla un mensaje con la posición de la
	  entrada ARP <span class="shellscript">POS_ARP</span>, seguido del contenido de dicha entrada ARP.
	  </li><li>En otro caso: Imprimirá por pantalla un mensaje indicando que el valor indicado
	  no es un número entero: <span class="shellscript">Posición de entrada ARP no válida</span></li>
	  </ul>
	  <p>Se solicitan dos posibles soluciones:</p>
	  <ul><li><span class="shellscript">script_arp1.sh</span>: Basada en el comando <span class="shellscript">read</span> y estructuras de
	  control.
	  </li><li><span class="shellscript">script_arp2.sh</span>: Analizando la salida del comando <span class="shellscript">arp</span> mediante
	  comandos de análisis de texto.</li>
	  </ul>
	</li><li><span class="shellscript">script_param.sh</span>: Considere que en el shell actual se dispone de la variable:
	  <p>
	  <span class="shellscript">VAR="nombre=v1&amp;edad=v2&amp;tlf=v3"</span>
	  </p>
	  Escriba un shell-script que analice el valor de dicha variable y para cada uno de los parámetros extraiga su valor
	  y lo imprima por pantalla. Por ejemplo, que la salida sea:
	  <p>
	  <span class="shellscript">Cadena analizada: nombre=v1&amp;edad=v2&amp;tlf=v3</span>
<span class="shellscript">nombre: v1, edad: v2, tlf: v3.</span>
		</p>
	  Se solicitan dos posibles soluciones:
	  <ul><li><span class="shellscript">script_param1.sh</span>: Usando la variable de entorno <span class="shellscript">IFS</span>.
	  </li><li><span class="shellscript">script_param2.sh</span>: Sin usar <span class="shellscript">IFS</span>.</li>
	  </ul>
	</li></ol>
	
	
	
	
	<h1>
		<a id="_Toc444081237" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081237">
		<span>6</span> 
		<span>Anexo: Descriptores de ficheros y redirecciones</span></a>
	  </h1>
	  <p>Para facilitar el acceso a los distintos recursos del sistema (zona de almacenamiento en disco,
	  teclado, pantalla, socket,...), el kernel de Linux vincula cada recurso con un fichero, real (espacio en disco) o virtual
	  (en memoria, como /dev y /proc). Ejemplos habituales son:</p>
	  <table class="tablaNormal tablaDefiniciones">
		<tbody><tr>
		  <td class="celdaDestacada">
			<p class="centrado">
			Recurso</p>
		  </td>
		  <td class="celdaDestacada">
			<p class="centrado">
			Fichero</p>
		  </td>
		  

		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Directorio</p>
		  </td>
		  <td>
			<p class="centrado">
			/carpeta</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Pantalla</p>
		  </td>
		  <td>
			<p class="centrado">
			/dev/ttyXX</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Sockets TCP</p>
		  </td>
		  <td>
			<p class="centrado">
			/proc/net/tcp</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Fichero regular</p>
		  </td>
		  <td>
			<p class="centrado">
			/dir/file</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Teclado (según USB...)</p>
		  </td>
		  <td>
			<p class="centrado">
			/dev/uinput</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Proceso con PID xxxx</p>
		  </td>
		  <td>
			<p class="centrado">
			/proc/xxxx</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Disco duro</p>
		  </td>
		  <td>
			<p class="centrado">
			/dev/sda</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Ratón</p>
		  </td>
    	  <td>
			<p class="centrado">
			/dev/psaux</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p class="centrado">
			Caché ARP</p>
		  </td>
		  <td>
			<p class="centrado">
			/proc/net</p>
		  </td>
		</tr>
	  </tbody></table>
	 
	  <p>Cuando un proceso necesita acceder a un recurso, debe
	  realizar las siguientes operaciones:</p>
	  <ol>
	  <li>Abrir el fichero correspondiente a dicho recurso: el proceso indica al sistema la ruta del fichero,
	  especificando su intención de abrirlo para lectura (obtener información del recurso), escritura (enviar información al
	  recurso) o lectura/escritura; el sistema concederá el tipo de acceso solicitado según las características del recurso
	  (teclado, pantalla, ...) y los permisos que el usuario efectivo del proceso posea sobre el fichero. Como respuesta, el
	  sistema devolverá al proceso el 
	  <b>descriptor</b> (o descriptor de fichero) con el que el proceso podrá acceder al fichero.</li>
	  <li>Acceder al fichero/recurso usando el descriptor suministrado por el sistema: el proceso indicará el
	  descriptor al kernel, éste localiza el fichero y accede al recurso asociado.</li>
	  </ol>
	  <div class="centrado">
		<table class="tablaNormal">
		  <tbody><tr>
			<td>
			  <p class="centrado">
			  &nbsp;</p>
			</td>
			<td>
			  <p class="centrado">
			  kernel</p>
			</td>
			<td>
			  <p class="centrado">
			  &nbsp;</p>
			</td>
			<td>
			  <p class="centrado">
			  proceso</p>
			</td>
			<td>
			  <p class="centrado">
			  &nbsp;</p>
			</td>
		  </tr>
		  <tr>
			<td>
			  <p class="centrado">
			  Recurso</p>
			</td>
			<td>
			  <p class="centrado">
			  ⇔</p>
			</td>
			<td>
			  <p class="centrado">
			  Fichero</p>
			</td>
			<td>
			  <p class="centrado">
			  ⇔</p>
			</td>
			<td>
			  <p class="centrado">
			  Descriptor</p>
			</td>
		  </tr>
		  
		</tbody></table>
	  </div>
	  <p>&nbsp;</p>
	 
	  <p>Un descriptor no es más que un número entero
	  "n", con las siguientes características:</p>
	  <ul><li>
	  <span>Cada <b>proceso</b> tiene su propia tabla de <b>descriptores</b> para acceder a los <b>recursos/ficheros</b>; el fichero que un proceso tenga asociado al descriptor "n" es independiente del que puedan tener asociado para ese mismo descriptor los demás procesos del sistema. El conjunto de descriptores que tiene asociados un determinado proceso puede obtenerse con  <span class="shellscript">ls /proc/PID/fd/</span>, cambiando <span class="shellscript">PID</span> por el identificador de dicho proceso.</span>
	  
	  <table class="tablaNormal tablaDefiniciones">
		  <thead>
		  <tr>
			<td colspan="2">
			  <p class="centrado">
			  Proceso con PID xxxx</p>
			</td>
		  </tr>
		  </thead>
		  <tbody><tr>
			<td class="celdaDestacada">
			  <p class="centrado">
			  Fichero</p>
			</td>
			<td class="celdaDestacada">
			  <p class="centrado">
			  Descriptor</p>
			</td>
		  </tr>
		  <tr>
			<td>
			  <p class="centrado">
			  Fichero_A</p>
			</td>
			<td>
			  <p class="centrado">
			  0</p>
			</td>
		  </tr>
		  <tr>
			<td>
			  <p class="centrado">
			  Fichero_B</p>
			</td>
			<td>
			  <p class="centrado">
			  1</p>
			</td>
		  </tr>
		  <tr>
			<td>
			  <p class="centrado">
			  Fichero_C</p>
			</td>
			<td>
			  <p class="centrado">
			  2</p>
			</td>
		  </tr>
		  <tr>
			<td style="border-right:none; padding:0cm 5.0pt 0cm 5.0pt">
			  <p class="centrado">
			  ...</p>
			</td>
			<td>
			  <p class="centrado">
			  ...</p>
			</td>
		  </tr>
	  </tbody></table>
	  <p>
		<span>&nbsp;</span>
	  </p>
	  </li><li>
	  <span>Se dice que un descriptor es de <b><i>entrada</i></b>, <b><i>salida</i></b> o <b><i>entrada/salida</i></b> según el fichero al que esté asociado en ese instante (es posible cambiar el fichero al que está asociado un
	  descriptor) haya sido abierto por el proceso que posee dicho descriptor para lectura, escritura o lectura/escritura,
	  respectivamente.</span></li>
	  </ul>
	  <p>Al trabajar con un intérprete de comandos encontramos que, de manera habitual, los comandos suelen
	  imprimir su información en pantalla y obtenerla del teclado. Este funcionamiento se debe a los dos motivos
	  siguientes:</p>
	  <ol type="a"><li> 
	  <span>Muchas aplicaciones, especialmente pensadas para ser usadas en modo consola, son programadas para que, por defecto (sus <b>procesos</b>):</span>
	  <ul><li><i><u><span>Obtengan</span></u></i> datos del (<b>recurso</b> asociado al) <b>descriptor</b> "<b>0</b>": dado que éste es el descriptor del que convencionalmente las aplicaciones obtienen información, este descriptor suele denominarse "<b>entrada estándar</b> (a pesar de este nombre, dado su uso especial, internamente los descriptores “0, 1, 2” son de entrada/salida).
	  </li><li><i><u><span>Envíen</span></u></i> <span>su información al (<b>recurso</b> asociado al) <b>descriptor</b> "<b>1</b>": dado que éste es el descriptor al que convencionalmente las aplicaciones envían su información, este descriptor suele denominarse "<b>salida estándar</b>".</span>
	  </li><li><i><u><span>Envíen</span></u></i> <span>su información de errores al (<b>recurso</b> asociado al) <b>descriptor</b> "<b>2</b>": dado que éste es el descriptor al que convencionalmente las aplicaciones envían su información de errores, este descriptor suele denominarse "<b>salida de error estándar</b>".</span></li>
	  </ul>
	  <p>
		<span>Esta configuración "estándar" es la empleada por los comandos POSIX. Así, por ejemplo, los comandos
		"echo cadena" o "cat fichero" están preparados para imprimir (enviar la información) en el recurso
		asociado al descriptor <span class="shellscript">1</span> (salida estándar), o el comando <span class="shellscript">cat</span> (sin argumentos) está diseñado
		para obtener la información del recurso asociado al descriptor <span class="shellscript">0</span> (entrada estándar).</span>
	  </p>
	</li>
	<li>De forma <span>habitual</span>, el <b>proceso</b> (shell) de cualquier consola en modo comandos asocia el <b>descriptor</b>:
	<ul>
	<li><span class="shellscript">0</span>: al <b>recurso</b> "teclado (siempre, a través del fichero asociado a esos dispositivos (/dev/uinput,...), que puede variar según su tipo).
	</li>
	<li><span class="shellscript">1</span>: al <b>recurso</b> "pantalla".</li>
	<li><span class="shellscript">2</span>: al <b>recurso</b> "pantalla".</li>
	</ul>
	<p>Por <span>omisión</span>, cuando un proceso padre crea un proceso hijo, el proceso hijo sólo dispone de los descriptores "0, 1, 2", cada uno asociado al mismo recurso que en el proceso padre (el proceso hijo hereda la asociación descriptor-fichero para esos tres descriptores, el resto de descriptores no se "heredan"). Todo ello lleva a que en una consola de comandos, las órdenes "echo cadena" o "cat fichero" suelan imprimir por pantalla (recurso del descriptor <span class="shellscript">1</span>), o el comando <span class="shellscript">cat</span> (sin argumentos) obtenga la información del teclado (recurso del descriptor <span class="shellscript">0</span>), al heredar esa asociación descriptor-fichero del shell (proceso padre).</p>
	</li>
	</ol>
	<p>Sobre este comportamiento habitual, los intérpretes de comandos de Linux permiten:</p>
	<ul>
	<li>
	<span>Modificar</span> el fichero (recurso) asociado a cada descriptor estándar "0, 1, 2".</li>
	<li>
	<span>Asociar</span> ficheros a los descriptores no estándar (3 y posteriores).
	</li>
	</ul>
	<p>Para ello, la sintaxis a aplicar varía según el proceso sobre el que queramos establecer la nueva
	asociación fichero-descriptor sea el propio proceso shell que estamos utilizando, o sobre un comando (proceso hijo)
	invocado desde este shell (en programación C, por ejemplo, se realizaría con la función "open", entre otras).
	
	</p><h2>
	  <a id="_Toc444081238" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081238">6.1 Asociación para el Proceso Shell actual</a>
	</h2>
	<p>Para ello se emplea el comando "exec", mediante las siguientes sintaxis:</p>
	<table class="tablaNormal tablaDefiniciones">
	  <thead>
		<tr>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Sintaxis</b>
			</p>
		  </td>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Funcionalidad</b>
			</p>
		  </td>
		</tr>
	  </thead>
	  <tbody><tr>
		<td>
		  <p>
			<span class="shellscript">exec n&lt; fichero</span>
		  </p>
		</td>
		<td>
		  <p>
		  Asocia el descriptor de entrada "n" con "fichero" (archivo regular). Para abreviar, en todo el texto se usará el calificativo “descriptor de entrada” para indicar que en ese instante (puede
modificarse) el descriptor está asociado con un fichero abierto para “lectura”. Al igual para salida (escritura) y entrada/salida.
		  </p>
		</td>
	  </tr>
	  <tr style="page-break-inside:avoid;height:28.0pt">
		<td style=" height:28.0pt">
		  <p>
			<span class="shellscript">exec n&gt; fichero</span>
		  </p>
		</td>
		<td style="height:28.0pt">
		  <p>
		  Asocia el descriptor de salida "n" con "fichero"</p>
		</td>
	  </tr>
	  <tr style="page-break-inside:avoid;height:27.0pt">
		<td style=" height:27.0pt">
		  <p>
			<span class="shellscript">exec n&lt;&gt; fichero</span>
		  </p>
		</td>
		<td style="height:27.0pt">
		  <p>
		  Asocia el descriptor de 
		  <span class="TesMarcado">entrada y salida</span> "n" con "fichero"</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">exec n&lt;&amp;m</span>
		  </p>
		</td>
		<td>
		  <p>
		  Asocia el descriptor "n" con el mismo fichero al que actualmente (en el momento de ejecutar este comando)
		  está asociado el descriptor "m" (duplicado de descriptor).</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">exec n&lt;&amp;-</span>
		  </p>
		</td>
		<td>
		  <p>
		  Cierra el descriptor "n" (elimina su asociación con el fichero al que actualmente esté vinculado)</p>
		</td>
	  </tr>
	</tbody></table>
	<p>&nbsp;</p>
	<p>Por ejemplo, el siguiente comando permite asociar el archivo <span class="shellscript">/tmp/fichero</span> con el descriptor "4":</p>
	<p>
	  <span class="shellscript">exec 4&lt; /tmp/fichero</span>
	</p>
	<p>A partir de ello,&nbsp; cada vez que queramos que un comando realice operaciones de lectura/escritura
	sobre ese archivo, podremos aplicar los operadores de redirección (detallados más abajo) con dicho descriptor (en lugar de
	usar el nombre del archivo).&nbsp; Por ejemplo, para que el comando <span class="shellscript">ls</span>; envíe su información a ese archivo:</p>
	<p>
	  <span class="shellscript">ls &gt;&amp;4</span>
	</p>
	<h2>
	  <a id="_Toc444081239" href="http://trajano.us.es/~fjfj/shell/shellscript.htm#_Idx444081239">6.2 Asociación para un comando (proceso hijo) invocado desde el shell</a>
	</h2>
	<p>Ello se consigue mediante la técnica de "<b>redirección</b>", basada en la siguiente sintaxis (es importante que no haya espacios entre <span class="shellscript">n</span> y
	<span class="shellscript">op</span>) 
	:</p>
	<p><span class="shellscript">comando&nbsp;&nbsp;&nbsp; [n]op&nbsp;&nbsp;&nbsp; fichero/descriptor</span></p>
	<p>donde:</p><ul>
	<li>
	  <span class="shellscript">comando</span>: comando sobre el que aplicar la redirección. Recuerde que, conforme a la sintaxis de los
	  comandos simples, la redirección puede escribirse tanto después como antes del comando.
	</li>
	<li>
	  <span class="shellscript">n</span> (número entero, opcional): descriptor (asociado actualmente o no a algún fichero en el shell actual).
	  POSIX exige que se soporten, al menos, los valores <span class="shellscript">0, 1,..., 9</span>. El valor por omisión depende del operador
	  empleado.
	</li>
	<li>
	<span class="shellscript">op</span>: operador de redirección. Si se "escapa" el descriptor <span class="shellscript">n</span> se usará el descriptor por omisión (e.g. <span class="shellscript">echo \2&gt;fichero</span> asumirá el descriptor <span class="shellscript">1</span>). Si se escapa el operador de redirección, no se aplicará redirección alguna (e.g., <span class="shellscript">echo 2\&gt;fichero</span> imprime <span class="shellscript">2\&gt;fichero</span> al recurso del descriptor <span class="shellscript">1</span>)
	</li>
	<li>
	  <span class="shellscript">fichero/descriptor</span>; a asociar (según indique el operador) con el descriptor <span class="shellscript">n</span> descriptor.
	</li>
	</ul>
	  <p>
		<span>Al aplicar esa redirección sobre el comando, para el descriptor <span class="shellscript">n</span>, el comando (el proceso hijo que se
		crea) no heredará (aún en el caso de ser <span class="shellscript">n=0, 1 o 2</span>) la asociación descriptor-fichero del proceso shell
		padre, sino que asociará a dicho descriptor <span class="shellscript">n</span> el "fichero" explícitamente indicado.</span>
	  </p>
	  <p>
		<span>A continuación se resumen los operadores de redirección definidos por el estándar POSIX, agrupadas según operen
		sobre descriptores para entrada (lectura de fichero) o salida (escritura en fichero):</span>
	  </p>
	  <ol type="a">
	  <li>Redirecciones de <b>entrada</b>: por omisión, toman <span class="shellscript">n=0</span> (entrada estándar).
	  
	  
	  <table class="tablaNormal tablaDefiniciones3">
		<thead>
		  <tr>
			<td class="celdaDestacada">
			  <p class="centrado">

				<b>Redirección</b>
			  </p>
			</td>
			<td class="celdaDestacada">
			  <p class="centrado">

				<b>Funcionalidad: El shell invoca <span class="shellscript">comando</span> como proceso hijo, configurándolo para que:</b>
			  </p>
			</td>
		  </tr>
		</thead>
		<tbody><tr>
		  <td>
			<p>
			  <span class="shellscript">cmd [n]&lt; fichero</span>
			</p>
		  </td>
		  <td>
			<p>Asocie el
			descriptor de entrada (recuérde que, para abreviar, se está usando el calificativo "descriptor de entrada" para indicar que en ese instante el descriptor está asociado con un fichero abierto para lectura, pero puede cambiar) <span class="shellscript">n</span>; con <span class="shellscript">fichero</span> (archivo regular). Por omisión <span class="shellscript">n=0</span>, esto es, <span class="shellscript">comando &lt; fichero</span> hace que para el proceso <span class="shellscript">comando</span>, el descriptor <span class="shellscript">0</span> quede asociado a
			<span class="shellscript">fichero</span> para lectura.</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p>
			  <span class="shellscript">cmd [n]&lt;&amp;m</span>
			</p>
		  </td>
		  <td>
			<p>Asocie el descriptor de entrada <span class="shellscript">n</span> con el mismo fichero al que actualmente está asociado el descriptor <span class="shellscript">m</span>. Dicho fichero estará así referenciado desde dos descriptores (duplicado de descriptores).
			<span class="shellscript">m</span> es obligatorio.</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p>
			  <span class="shellscript">cmd [n]&lt;&amp;-</span>
			</p>
		  </td>
		  <td>
			<p>Cierre el descriptor de entrada <span class="shellscript">n</span> (elimina su asociación con el fichero al que actualmente esté vinculado). Si el descriptor no está asociado con ningún fichero, dará error.</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p>
			  <span class="shellscript">cmd [n]&lt;&lt; delimitador</span>
			</p>
		  </td>
		  <td>
			<p>
			Asocie el descriptor de 
			<b>entrada</b> <span class="shellscript">n</span> con el recurso especial <span class="shellscript">Here-Document</span> (texto
			empotrado). Tras ejecutar la orden, aparecerá en consola el carácter <span class="shellscript">&gt;</span>; el texto introducido a
			partir de entonces será guardado en el recurso <span class="shellscript">Here-Document</span>, terminando cuando se introduzca una línea
			que sólo contenga (incluidos espacios en blanco) la cadena <span class="shellscript">delimitador</span> y se pulse nueva línea; en dicho momento, <span class="shellscript">comando</span> será ejecutado (pudiendo acceder al contenido del recurso <span class="shellscript">Here-Document</span> a través del descriptor <span class="shellscript">n</span>). Si al escribir la orden, la cadena <span class="shellscript">delimitador</span> se introduce entre comillas, el shell las eliminará, de modo que para terminar de escribir en el recurso <span class="shellscript">Here-Document</span>, habrá que escribir la cadena <span class="shellscript">delimitador</span> sin comillas.</p>
		  </td>
		</tr>
		<tr>
		  <td>
			<p>
			  <span class="shellscript">cmd &lt;&lt;- delimitador</span>
			</p>
		  </td>
		  <td>
			<p>Ídem
			<span class="shellscript">&lt;&lt;</span>, pero las tabulaciones añadidas al principio de línea será omitidas, no insertándose en el
			recurso <span class="shellscript">Here-Document</span>.</p>
		  </td>
		</tr>
	  </tbody></table>
	</li>
	<li>
	<span>Redirecciones</span> de 
	<b>salida</b>: por omisión, toman <span class="shellscript">n=1</span> (salida estándar).
	<table class="tablaNormal tablaDefiniciones">
	  <thead>
		<tr>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Redirección</b>
			</p>
		  </td>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Funcionalidad: El shell invoca <span class="shellscript">comando</span> como proceso hijo, configurándolo para que:</b>
			</p>
		  </td>
		</tr>
	  </thead>
	  <tbody><tr>
		<td>
		  <p>
			<span class="shellscript">cmd [n]&gt; fichero</span>
		  </p>
		</td>
		<td>
		  <p>
		  Asocie el descriptor de salida <span class="shellscript">n</span> con <span class="shellscript">fichero</span> (archivo regular). Por omisión <span class="shellscript">n=1</span>,
		  esto es, <span class="shellscript">comando &gt; fichero</span> hace que para el proceso <span class="shellscript">comando</span>, el descriptor <span class="shellscript">1</span>
		  quede asociado a <span class="shellscript">fichero</span>. Si <span class="shellscript">fichero</span> no existe, será creado; si existe, será limpiado
		  previamente. Salvo que se haya activado en el shell la opción “no sobrescribir” con el comando <span class="shellscript">set -C</span> (recuerde que el comando <span class="shellscript">set</span> permite modificar el comportamiento del shell, incluyendo opciones y el valor de sus variables) en cuyo caso dará error.</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">cmd [n]&gt;| fichero</span>
		  </p>
		</td>
		<td>
		  <p>
		  Ídem <span class="shellscript">&gt;</span>, sin depender de la opción "no sobrescribir" (<span class="shellscript">set -C</span>).</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">cmd [n]&gt;&gt; fichero</span>
		  </p>
		</td>
		<td>
		  <p>
		  Ídem <span class="shellscript">&gt;</span>, sin limpiar previamente el fichero si existe (insertando al final del contenido
		  existente).</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">cmd [n]&gt;&amp; m</span>
		  </p>
		</td>
		<td>
		  <p>
		  Asocie el descriptor de salida <span class="shellscript">n</span> con el mismo fichero al que está asociado el descriptor <span class="shellscript">m</span>.
		  Dicho fichero estará así referenciado desde dos descriptores (duplicado de descriptores). <span class="shellscript">m</span> es
		  obligatorio.</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">cmd [n]&gt;&amp; -</span>
		  </p>
		</td>
		<td>
		  <p>
		  Cierre el descriptor de salida <span class="shellscript">n</span> (elimina su asociación con el fichero al que actualmente esté vinculado). Si el descriptor no está asociado con ningún fichero, dará error. 
		  </p>
		</td>
	  </tr>
	</tbody></table>
	<p>&nbsp;</p>
	</li><li><span>Redirecciones</span> de 
	<b>entrada/salida</b>: por omisión, toman <span class="shellscript">n=1</span> (salida estándar).
	<table class="tablaNormal tablaDefiniciones3">
	  <thead>
		<tr>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Redirección</b>
			</p>
		  </td>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Funcionalidad: El shell invoca <span class="shellscript">comando</span> como proceso hijo, configurándolo para que:</b>
			</p>
		  </td>
		</tr>
	  </thead>
	  <tbody><tr>
		<td>
		  <p>
			<span class="shellscript">cmd [n]&lt;&gt;fichero</span>
		  </p>
		</td>
		<td>
		  <p>
		  Asocie el descriptor <span class="shellscript">n</span> de entrada y salida con <span class="shellscript">fichero</span> (archivo regular, será creado si no
		  existe).</p>
		</td>
	  </tr>
	</tbody></table>
	<p>&nbsp;</p>
	</li>
	</ol>
	<p>Además de 
	<span>las</span> anteriores, existe un tipo especial de redirección denominado 
	<b>tubería</b> o&nbsp; "pipeline", en la cual el "recurso" sería esa "tubería" que conecta
	dos descriptores. Esta redirección se basa en la siguiente sintaxis:</p>
	<p>
	  <span class="shellscript">comando1&nbsp; <b>|</b>&nbsp; comando2</span>
	</p>
	<p>bajo la cual, el descriptor <span class="shellscript">0</span> de <span class="shellscript">comando2</span> se asociaría con el descriptor
	<span class="shellscript">1</span> de <span class="shellscript">comando1</span> (esto es, lo que <span class="shellscript">comando1</span> envíe a su salida estándar será redirigido a la
	entrada estándar de <span class="shellscript">comando2</span>). Pueden usarse dos o más comandos separados por <span class="shellscript">|</span>.</p>
	
	<p>A continuación se proponen varios ejemplos de redirección y su explicación:</p>
	<table class="tablaNormal tablaDefiniciones3">
	  <tbody><tr>
		<td>
		  <p class="shellscript">
cat &lt; fichero
		  </p>
		</td>
		<td>
		  <p>
		  Por omisión <span class="shellscript">cat</span> tiene el recurso "teclado" asociado al descriptor <span class="shellscript">0</span> (POSIX). Con
		  este comando, <span class="shellscript">cat</span> es invocado para que su descriptor <span class="shellscript">0</span> quede asociado al recurso
		  <span class="shellscript">fichero</span>, de modo que <span class="shellscript">cat</span> toma la entrada de dicho fichero.</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p class="shellscript">
ls / &gt; fichero
		  </p>
		</td>
		<td>
		  <p>
		  <span class="shellscript">ls</span> es invocado para que su descriptor <span class="shellscript">1</span> esté asociado a <span class="shellscript">fichero</span> (y no a la "pantalla" a que está asociado en el shell desde el que es invocado), esto es, <span class="shellscript">ls</span> envía su
		  salida a <span class="shellscript">fichero</span>.</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p class="shellscript">
cat &lt;&lt; fin
		  </p>
		</td>
		<td>
		  <p>
		  Toda la información escrita tras invocar el comando es guardada en el recurso especial <span class="shellscript">Here-Document</span>, pasándose al comando <span class="shellscript">cat</span> cuando se introduzca la línea <span class="shellscript">fin</span> y se pulse nueva línea.</p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p class="shellscript">
ls | more
		  </p>
		</td>
		<td>
		  <p>
		  El descriptor de salida de <span class="shellscript">ls</span> se conecta con el de entrada de <span class="shellscript">more</span>, de modo que toda la salida <span class="shellscript">ls</span> de entrega a <span class="shellscript">more</span> como entrada.</p>
		</td>
	  </tr>
	</tbody></table>
	<p>&nbsp;</p>
	<p>Adicionalmente a lo anterior, deben realizarse las siguientes aclaraciones sobre las
	redirecciones:</p>
	<ol type="a"><li>Las redirecciones son aplicables a cualquier comando, incluso a subshells (shell abierto desde otro shell), de modo
	que todos los comandos abiertos desde dicho subshell heredarán por defecto su asociación de los descriptores <span class="shellscript">0, 1, 2</span>. Por ejemplo, si en un shell ejecutamos:
	<p>
	  <span class="shellscript">echo "Hola" &gt; /tmp/fichero</span>
	</p>
	<p>
	  <span class="shellscript">/bin/bash &lt; /tmp/fichero</span>
	</p>	
	<p>
	  <span>con el segundo comando se estará abriendo un nuevo proceso shell (subshell), el cual tendrá asociado el descriptor
	  <span class="shellscript">0</span> con el archivo <span class="shellscript">/tmp/fichero</span>. Si en dicho subshell abierto ejecutamos ahora:</span>
	</p>
	<p><span class="shellscript">cat</span>
	</p>
	<p>
	<span>este comando hereda la configuración del subshell, teniendo igualmente asociado el descriptor <span class="shellscript">0</span> con el
	archivo <span class="shellscript">/tmp/fichero</span>. El comando <span class="shellscript">cat</span>, al ser invocado sin argumentos, sigue el estándar POSIX,
	imprimiendo en el recurso asociado al descriptor <span class="shellscript">2</span> (la pantalla en este caso) la información obtenida del
	recurso asociado al descriptor <span class="shellscript">0</span>, que en este caso será el archivo <span class="shellscript">fichero</span>; (y no el teclado).
	Consecuentemente, el resultado es que dicho comando <span class="shellscript">cat</span> imprime directamente por pantalla el contenido de
	<span class="shellscript">fichero</span>. El orden de lectura de los comandos es importante. Por ejemplo, <span class="shellscript">(cat &lt;&lt; fin) &lt; fichero</span> no hará que <span class="shellscript">fichero</span> se pase a <span class="shellscript">cat</span>, dado que <span class="shellscript">&lt; fichero</span> no se aplicará hasta que no haya terminado el comando <span class="shellscript">cat</span>. Por ejemplo:</span></p>
	<p>
	<span class="shellscript">cat</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;["Ctrl-D" para terminar, que equivale a enviar EOF]
	</p>
	<p>
	<span class="shellscript">cat &lt;&lt; fin</span> &nbsp;&nbsp;&nbsp;&nbsp;<span>[Teclear "fin" y Enter para terminar]</span>
	</p>
	</li><li>El orden en el que se escriban las redirecciones es importante, pudiendo cambiar el resultado. Por ejemplo, en el
	comando:
	<ul><li> 
	<span class="shellscript">ls /tmp 2&gt; file 1&gt;&amp;2</span><span>:</span> sucedería lo siguiente (en este orden):
	<ul>
	<li>
	El descriptor <span class="shellscript">2</span> se asocia con <span class="shellscript">file</span>.</li>
	<li>El descriptor <span class="shellscript">1</span> se asocia con el mismo fichero al que está asociado el descriptor <span class="shellscript">2</span>, luego
	con <span class="shellscript">file</span> también.</li>
	<li>Se ejecuta el comando <span class="shellscript">ls</span>, que enviará sus salidas estándar (1) y de errores (2) a <span class="shellscript">file</span>. En un comando simple, el comando siempre se ejecuta tras aplicar las posibles expansiones/sustituciones e interpretar las
redirecciones (leyéndose en orden de izquierda a derecha).</li>
	</ul>
	</li>
	<li>
	<span class="shellscript">1&gt;&amp;2 ls /tmp 2&gt; file</span> <span>: sucederá lo siguiente (en este orden):</span>
	<ul>
	<li>El descriptor <span class="shellscript">1</span> se asocia con el mismo fichero (o recurso, e.g. pantalla) al que actualmente esté
	asociado el descriptor <span class="shellscript">2</span>.
	</li>
	<li>El descriptor <span class="shellscript">2</span> se asocia con <span class="shellscript">file</span>.
	</li>
	<li>Se ejecuta el comando <span class="shellscript">ls</span>, que enviará su salida de errores a <span class="shellscript">file</span>, y su salida estándar (1)
	con ese recurso (posiblemente pantalla) al que inicialmente estuviese asociado el descriptor <span class="shellscript">2</span>.
	</li>
	</ul>
	</li>
	</ul>
	
	</li><li>
	<span>Para redireccionar una información a "ninguna parte" se usa el fichero nulo <span class="shellscript">/dev/null</span> (fichero que podría considerarse asociado al recurso virtual "destructor de información")</span>
	<span>. Por ejemplo, el siguiente comando haría toda la información que <span class="shellscript">ls</span> envíe a la salida estándar
	(descriptor <span class="shellscript">1</span>) y a la salida de errores (descriptor <span class="shellscript">2</span>) sea enviada a <span class="shellscript">/dev/null</span> (se elimina):</span>
	<p>
	  <span class="shellscript">ls -l /usr &gt; /dev/null 2&gt;&amp;1</span>
	</p>
	</li>
	</ol>
	<table class="tablaTarea">
	  <tbody><tr>
		<td class="tareaTitulo">
		  <p>TAREAS</p>
		</td>
		<td class="tareaContenido">
		  <p class="Lista-Tareas">
			<span>Ejecute y analice el funcionamiento de las redirecciones empleadas en los siguientes comandos:</span>
		  </p>
		  <ul>
		  <li>
		  <span class="shellscript">cat &lt;&lt; END &gt; fichero</span> 
		  : lee información del teclado, hasta que se introduce una línea con END. Entonces copia toda la información tecleada al archivo <span class="shellscript">fichero</span>.</li>
		  <li>
		  <span class="shellscript">ls -l /bin/bash ./script &gt; fichero 2&gt; error</span> 
		  : redirige la salida estándar al archivo <span class="shellscript">fichero</span> y la salida de error al fichero
		  <span class="shellscript">error</span>.</li>
		  <li>
		  <span class="shellscript">ls -l /bin/bash ./script &gt; fichero 2&gt;&amp;1</span> 
		  : redirige las salidas estándar y de error al archivo <span class="shellscript">fichero</span>.</li>
		  <li>
		  <span class="shellscript">ls 2&gt; /dev/null 1&gt;&amp;2</span> 
		  : redirige las salidas estándar y de error al archivo nulo.</li>
		  </ul>

		</td>
	  </tr>
	</tbody></table>

	<p>Por último, advertir que la explicación anterior corresponde al estándar POSIX. Algunos intérpretes de
	comandos como Bash soportan otros operadores (además de los POSIX). A continuación se resumen algunos de los ofrecidos por
	Bash:</p>
	<table class="tablaNormal tablaDefiniciones3">
	  <thead>
		<tr>
		  <td class="celdaDestacada">
			<p class="centrado">
			Redirección Bash ( 
			<b>NO POSIX!!</b>)</p>
		  </td>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Descripción</b>
			</p>
		  </td>
		  <td class="celdaDestacada">
			<p class="centrado">
			  <b>Equivalente POSIX</b>
			</p>
		  </td>
		</tr>
	  </thead>
	  <tbody><tr>
		<td>
		  <p>
			<span class="shellscript">cmd &amp;&gt; fich</span>
		  </p>
		</td>
		<td rowspan="2">
		  <p>
		  Asocia los descriptores <span class="shellscript">1</span> y <span class="shellscript">2</span> con el recurso "fichero"</p>
		</td>
		<td rowspan="2">
		  <p>
			<span class="shellscript">cmd &gt; fich 2&gt;&amp;1</span>
		  </p>
		</td>
	  </tr>
	  <tr>
		<td>
		  <p>
			<span class="shellscript">cmd &gt;&amp; fich</span>
		  </p>
		</td>
	  </tr>
	</tbody></table>
	<p>&nbsp;</p>
	<p>&nbsp;</p>
  
</div>
  <p style="text-align: right"><a href="http://trajano.us.es/~fjfj/shell/FAST_t3-practica.pdf">Descargar versión antigua en PDF</a></p>
	

</body></html>